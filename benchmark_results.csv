"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""image/png""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTriangles(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	var directColor color.RGBA
	if !inShadow {
		lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]Triangle
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &triangles,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64, mouseX, mouseY int, mousePressed bool) {
	// Draw background
	bgColor := color.RGBA{50, 50, 50, 255}
	bgRect := image.Rect(x, y, x+width, y+height)
	draw.Draw(screen, bgRect, &image.Uniform{bgColor}, image.Point{}, draw.Src)

	// Preview area
	previewRect := image.Rect(x, y, x+width, y+height/2)
	draw.Draw(screen, previewRect, &image.Uniform{color.RGBA{uint8(*r * 255), uint8(*g * 255), uint8(*b * 255), uint8(*a * 255)}}, image.Point{}, draw.Src)

	// Draw sliders
	sliderWidth := width - 20
	sliderHeight := 20    // Height of the slider track
	indicatorHeight := 15 // Height of the indicator
	sliderY := y + height/2 + 10
	padding := 10 // Vertical padding between sliders

	// Create sliders for R, G, B, and Alpha
	sliders := []struct {
		label string
		value *float64
	}{
		{""R"", r},
		{""G"", g},
		{""B"", b},
		{""A"", a},
	}

	for i, slider := range sliders {
		// Draw the slider track
		trackRect := image.Rect(x+10, sliderY+20*i+(padding*i), x+10+sliderWidth, sliderY+20*i+(padding*i)+sliderHeight)
		draw.Draw(screen, trackRect, &image.Uniform{color.RGBA{200, 200, 200, 255}}, image.Point{}, draw.Src)

		// Calculate the current slider position
		valueX := int(*slider.value*float64(sliderWidth)) + x + 10
		valueRect := image.Rect(valueX-5, sliderY+20*i+(padding*i)+(sliderHeight-indicatorHeight)/2, valueX+5, sliderY+20*i+(padding*i)+(sliderHeight-indicatorHeight)/2+indicatorHeight)
		draw.Draw(screen, valueRect, &image.Uniform{color.RGBA{255, 0, 0, 255}}, image.Point{}, draw.Src) // Use red for the current value

		// Draw label
		ebitenutil.DebugPrintAt(screen, slider.label, x+10, sliderY+20*i+(padding*i)+5)

		// Check for mouse collision and update value
		if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
			// Calculate the new value based on mouse position
			newValue := float64(mouseX-x-10) / float64(sliderWidth)
			if newValue < 0 {
				newValue = 0
			} else if newValue > 1 {
				newValue = 1
			}
			*slider.value = newValue
		}
	}
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangle(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating average FPS only..."")

			// Parse the existing average FPS
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}

			// Calculate new averaged FPS (only updating the average)
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)

			// Update the record with new average FPS only
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", MinFrameRate)    // Update min FPS
			records[i][3] = fmt.Sprintf(""%.2f"", MaxFrameRate)    // Update max FPS
			records[i][4] = fmt.Sprintf(""%.2f"", min10PercentFPS) // Update min 15% FPS

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)})
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
			} else {
				g.samples = 0
			}
		}

	}
	return nil
}

func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
	// Get the size of the Ebiten image
	width, height := ebitenImg.Size()

	// Create an RGBA image to hold the pixel data
	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			c := ebitenImg.At(x, y).(color.RGBA)
			rgba.Set(x, y, c)
		}
	}

	// Create the output file
	outFile, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer outFile.Close()

	// Encode the RGBA image as a PNG and save it
	err = png.Encode(outFile, rgba)
	if err != nil {
		return err
	}

	return nil
}

func (g *Game) Draw(screen *ebiten.Image) {

	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Display frame rate
	fps := ebiten.ActualFPS()

	g.currentFrame.Clear()

	// Perform path tracing and draw rays into the current frame
	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, g.depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i)) // Use the outer loop variable directly
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	op := &ebiten.DrawImageOptions{}
	if fullScreen {
		g.scaleFactor = 2
		op.GeoM.Scale(float64(screen.Bounds().Dx())/float64(g.currentFrame.Bounds().Dx()), float64(screen.Bounds().Dy())/float64(g.currentFrame.Bounds().Dy()))
	} else {
		g.scaleFactor = 4
		op.GeoM.Scale((float64(screenWidth) / float64(g.currentFrame.Bounds().Dx())), (float64(screenHeight) / float64(g.currentFrame.Bounds().Dy())))
		// Draw GUI Element
	}

	screen.DrawImage(g.currentFrame, op)

	// Get mouse position
	mouseX, mouseY := ebiten.CursorPosition()
	// Get mouse pressed
	mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

	if !fullScreen {
		ColorSlider(400, 0, screen, 400, 300, &g.r, &g.g, &g.b, &g.a, mouseX, mouseY, mousePressed) // Example usage with RGBA values
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	depth            int
	ditherColor      *ebiten.Shader
	ditherGrayScale  *ebiten.Shader
	bloomShader      *ebiten.Shader
	contrastShader   *ebiten.Shader
	tintShader       *ebiten.Shader
	sharpnessShader  *ebiten.Shader
	r, g, b, a       float64
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
var bayerMatrix = [16]float32{
	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
}

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 1}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		depth:       2,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",217.45,0.19,272.23,32.40
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""image/png""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTriangles(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	var directColor color.RGBA
	if !inShadow {
		lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]Triangle
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &triangles,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
    bgColor        = color.RGBA{50, 50, 50, 255}
    trackColor     = color.RGBA{200, 200, 200, 255}
    colorSliderInd = color.RGBA{255, 0, 0, 255}
    propSliderInd  = color.RGBA{0, 255, 255, 255}
    
    bgUniform        = &image.Uniform{bgColor}
    trackUniform     = &image.Uniform{trackColor}
    colorSliderUnif  = &image.Uniform{colorSliderInd}
    propSliderUnif   = &image.Uniform{propSliderInd}
)

type SliderLayout struct {
    sliderWidth     int
    sliderHeight    int
    indicatorHeight int
    padding         int
    startX          int
    startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64, 
    reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {
    
    // Calculate layout once
    layout := SliderLayout{
        sliderWidth:     width - 20,
        sliderHeight:    18,
        indicatorHeight: 15,
        padding:         5,
        startX:          x + 10,
        startY:          y + height/2 + 10,
    }

    // Draw background (single allocation)
    draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

    // Draw preview area
    previewColor := &image.Uniform{color.RGBA{
        uint8(*r * 255),
        uint8(*g * 255),
        uint8(*b * 255),
        uint8(*a * 255),
    }}
    draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

    // Process sliders
    processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
    processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
    processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
    processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
    processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
    processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{}, 
    isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {
    
    // Calculate positions
    yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
    trackRect := image.Rect(
        layout.startX,
        yOffset,
        layout.startX+layout.sliderWidth,
        yOffset+layout.sliderHeight,
    )

    // Draw track
    draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

    // Get current value
    var currentValue float64
    if isFloat32 {
        currentValue = float64(*value.(*float32))
    } else {
        currentValue = *value.(*float64)
    }

    // Calculate and draw indicator
    valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
    indicatorRect := image.Rect(
        valueX-5,
        yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
        valueX+5,
        yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
    )

    // Draw indicator with appropriate color
    if isFloat32 {
        draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
    } else {
        draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
    }

    // Draw label
    ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

    // Handle mouse interaction
    if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
        newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
        if isFloat32 {
            *value.(*float32) = float32(newValue)
        } else {
            *value.(*float64) = newValue
        }
    }
}


// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
    if value < 0 {
        return 0
    }
    if value > 1 {
        return 1
    }
    return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangle(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating average FPS only..."")

			// Parse the existing average FPS
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}

			// Calculate new averaged FPS (only updating the average)
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)

			// Update the record with new average FPS only
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", MinFrameRate)    // Update min FPS
			records[i][3] = fmt.Sprintf(""%.2f"", MaxFrameRate)    // Update max FPS
			records[i][4] = fmt.Sprintf(""%.2f"", min10PercentFPS) // Update min 15% FPS

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
			} else {
				g.samples = 0
			}
		}

	}
	return nil
}

func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
	// Get the size of the Ebiten image
	width, height := ebitenImg.Size()

	// Create an RGBA image to hold the pixel data
	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			c := ebitenImg.At(x, y).(color.RGBA)
			rgba.Set(x, y, c)
		}
	}

	// Create the output file
	outFile, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer outFile.Close()

	// Encode the RGBA image as a PNG and save it
	err = png.Encode(outFile, rgba)
	if err != nil {
		return err
	}

	return nil
}

var (
    GUI = ebiten.NewImage(400, 300)
    lastMousePressed bool
    guiNeedsUpdate  = true  // Start with true to ensure initial render
)

func (g *Game) Draw(screen *ebiten.Image) {
    // Increment frame count and add current FPS to the average
    if Benchmark {
        FrameCount++
        fps := ebiten.ActualFPS()
        AverageFrameRate += fps

        MinFrameRate = math.Min(MinFrameRate, fps)
        MaxFrameRate = math.Max(MaxFrameRate, fps)

        FPS = append(FPS, fps)
    }

    // Clear the current frame
    g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

    // Perform path tracing and draw rays into the current frame
    DrawRays(g.camera, g.light, g.scaleFactor, g.samples, g.depth, g.subImages)
    for i, subImage := range g.subImages {
        op := &ebiten.DrawImageOptions{}
        if !fullScreen {
            op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
        } else {
            op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
        }
        g.currentFrame.DrawImage(subImage, op)
    }

    // Scale the main render
    mainOp := &ebiten.DrawImageOptions{}
    if fullScreen {
        g.scaleFactor = 2
        mainOp.GeoM.Scale(
            float64(screen.Bounds().Dx())/float64(g.currentFrame.Bounds().Dx()),
            float64(screen.Bounds().Dy())/float64(g.currentFrame.Bounds().Dy()),
        )
    } else {
        g.scaleFactor = 4
        mainOp.GeoM.Scale(
            (float64(screenWidth) / float64(g.currentFrame.Bounds().Dx())),
            (float64(screenHeight) / float64(g.currentFrame.Bounds().Dy())),
        )
    }

    // Draw the main render first
    screen.DrawImage(g.currentFrame, mainOp)

    // Handle GUI separately
    if !fullScreen {
        mouseX, mouseY := ebiten.CursorPosition()
        mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

        // Check if GUI needs updating
        if mousePressed || lastMousePressed != mousePressed {
            guiNeedsUpdate = true
        }

        // Only update GUI if needed
        if guiNeedsUpdate {
            GUI.Clear()
            ColorSlider(0, 0, GUI, 400, 300, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
            guiNeedsUpdate = false
        }

        // Draw GUI on top of the main render
        guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
        screen.DrawImage(GUI, guiOp)

        lastMousePressed = mousePressed
    }

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	depth            int
	ditherColor      *ebiten.Shader
	ditherGrayScale  *ebiten.Shader
	bloomShader      *ebiten.Shader
	contrastShader   *ebiten.Shader
	tintShader       *ebiten.Shader
	sharpnessShader  *ebiten.Shader
	r, g, b, a       float64
	specular         float32
	reflection       float32
	previousFrame    *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
var bayerMatrix = [16]float32{
	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
}

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		depth:       2,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",206.35,0.19,254.16,26.61
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""image/png""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTriangles(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	var directColor color.RGBA
	if !inShadow {
		lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]Triangle
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &triangles,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}
)

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangle(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating average FPS only..."")

			// Parse the existing average FPS
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}

			// Calculate new averaged FPS (only updating the average)
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)

			// Update the record with new average FPS only
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", MinFrameRate)    // Update min FPS
			records[i][3] = fmt.Sprintf(""%.2f"", MaxFrameRate)    // Update max FPS
			records[i][4] = fmt.Sprintf(""%.2f"", min10PercentFPS) // Update min 15% FPS

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
			} else {
				g.samples = 0
			}
		}

	}
	return nil
}

func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
	// Get the size of the Ebiten image
	width, height := ebitenImg.Size()

	// Create an RGBA image to hold the pixel data
	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			c := ebitenImg.At(x, y).(color.RGBA)
			rgba.Set(x, y, c)
		}
	}

	// Create the output file
	outFile, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer outFile.Close()

	// Encode the RGBA image as a PNG and save it
	err = png.Encode(outFile, rgba)
	if err != nil {
		return err
	}

	return nil
}

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame
	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, g.depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	if fullScreen {
		g.scaleFactor = 2
		mainOp.GeoM.Scale(
			float64(screen.Bounds().Dx())/float64(g.currentFrame.Bounds().Dx()),
			float64(screen.Bounds().Dy())/float64(g.currentFrame.Bounds().Dy()),
		)
	} else {
		g.scaleFactor = 4
		mainOp.GeoM.Scale(
			(float64(screenWidth) / float64(g.currentFrame.Bounds().Dx())),
			(float64(screenHeight) / float64(g.currentFrame.Bounds().Dy())),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 0, GUI, 400, 300, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	depth            int
	ditherColor      *ebiten.Shader
	ditherGrayScale  *ebiten.Shader
	bloomShader      *ebiten.Shader
	contrastShader   *ebiten.Shader
	tintShader       *ebiten.Shader
	sharpnessShader  *ebiten.Shader
	r, g, b, a       float64
	specular         float32
	reflection       float32
	previousFrame    *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
var bayerMatrix = [16]float32{
	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
}

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		depth:       2,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",206.31,0.19,252.36,19.13
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTriangles(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	var directColor color.RGBA
	if !inShadow {
		lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]Triangle
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &triangles,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}
)

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangle(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating average FPS only..."")

			// Parse the existing average FPS
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}

			// Calculate new averaged FPS (only updating the average)
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)

			// Update the record with new average FPS only
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", MinFrameRate)    // Update min FPS
			records[i][3] = fmt.Sprintf(""%.2f"", MaxFrameRate)    // Update max FPS
			records[i][4] = fmt.Sprintf(""%.2f"", min10PercentFPS) // Update min 15% FPS

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
			} else {
				g.samples = 0
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame
	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, g.depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	if fullScreen {
		g.scaleFactor = 2
		mainOp.GeoM.Scale(
			float64(screen.Bounds().Dx())/float64(g.currentFrame.Bounds().Dx()),
			float64(screen.Bounds().Dy())/float64(g.currentFrame.Bounds().Dy()),
		)
	} else {
		g.scaleFactor = 4
		mainOp.GeoM.Scale(
			(float64(screenWidth) / float64(g.currentFrame.Bounds().Dx())),
			(float64(screenHeight) / float64(g.currentFrame.Bounds().Dy())),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 0, GUI, 400, 300, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	depth            int
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a    float64
	specular      float32
	reflection    float32
	previousFrame *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		depth:       2,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",203.64,0.19,259.95,25.01
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTriangles(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	var directColor color.RGBA
	if !inShadow {
		lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]Triangle
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &triangles,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}
)

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangle(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating average FPS only..."")

			// Parse the existing average FPS
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averaged FPS (only updating the average)
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := math.Min(existingMinFPS, MinFrameRate)
			newMaxFPS := math.Max(existingMaxFPS, MaxFrameRate)
			newMin10PercentFPS := math.Min(existingMin10PercentFPS, min10PercentFPS)
			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new average FPS only
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)    // Update min FPS
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)    // Update max FPS
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS) // Update min 15% FPS

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
			} else {
				g.samples = 0
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame
	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, g.depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	if fullScreen {
		g.scaleFactor = 2
		mainOp.GeoM.Scale(
			float64(screen.Bounds().Dx())/float64(g.currentFrame.Bounds().Dx()),
			float64(screen.Bounds().Dy())/float64(g.currentFrame.Bounds().Dy()),
		)
	} else {
		g.scaleFactor = 4
		mainOp.GeoM.Scale(
			(float64(screenWidth) / float64(g.currentFrame.Bounds().Dx())),
			(float64(screenHeight) / float64(g.currentFrame.Bounds().Dy())),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 0, GUI, 400, 300, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	depth            int
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a    float64
	specular      float32
	reflection    float32
	previousFrame *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		depth:       2,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",203.07,0.18,260.43,12.22
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTriangles(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	var directColor color.RGBA
	if !inShadow {
		lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]Triangle
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &triangles,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}
)

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangle(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating average FPS only..."")

			// Parse the existing average FPS
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averaged FPS (only updating the average)
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2
			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new average FPS only
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)          // Update min FPS
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)          // Update max FPS
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS) // Update min 15% FPS

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
			} else {
				g.samples = 0
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame
	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, g.depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	if fullScreen {
		g.scaleFactor = 2
		mainOp.GeoM.Scale(
			float64(screen.Bounds().Dx())/float64(g.currentFrame.Bounds().Dx()),
			float64(screen.Bounds().Dy())/float64(g.currentFrame.Bounds().Dy()),
		)
	} else {
		g.scaleFactor = 4
		mainOp.GeoM.Scale(
			(float64(screenWidth) / float64(g.currentFrame.Bounds().Dx())),
			(float64(screenHeight) / float64(g.currentFrame.Bounds().Dy())),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 0, GUI, 400, 300, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	depth            int
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a    float64
	specular      float32
	reflection    float32
	previousFrame *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		depth:       2,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",132.02,0.18,233.74,5.32
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTriangles(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	var directColor color.RGBA
	if !inShadow {
		lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]Triangle
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &triangles,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}
)

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangle(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
			} else {
				g.samples = 0
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame
	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, g.depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	if fullScreen {
		g.scaleFactor = 2
		mainOp.GeoM.Scale(
			float64(screen.Bounds().Dx())/float64(g.currentFrame.Bounds().Dx()),
			float64(screen.Bounds().Dy())/float64(g.currentFrame.Bounds().Dy()),
		)
	} else {
		g.scaleFactor = 4
		mainOp.GeoM.Scale(
			(float64(screenWidth) / float64(g.currentFrame.Bounds().Dx())),
			(float64(screenHeight) / float64(g.currentFrame.Bounds().Dy())),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 0, GUI, 400, 300, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	depth            int
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a    float64
	specular      float32
	reflection    float32
	previousFrame *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		depth:       2,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",215.17,0.20,265.47,26.54
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3 Vector
	color      color.RGBA
	Normal     Vector
	reflection float32
	specular   float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))

	var directColor color.RGBA
	if !inShadow {

		viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
		specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)*lightIntensity) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)*lightIntensity) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)*lightIntensity) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]TriangleSimple
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		trianglesSimple := make([]TriangleSimple, len(triangles))
		for i, triangle := range triangles {
			trianglesSimple[i] = TriangleSimple{
				v1: triangle.v1,
				v2: triangle.v2,
				v3: triangle.v3,
				color: color.RGBA{
					R: triangle.color.R,
					G: triangle.color.G,
					B: triangle.color.B,
					A: triangle.color.A,
				},
				Normal:     triangle.Normal,
				reflection: triangle.reflection,
				specular:   triangle.specular,
			}
		}

		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &trianglesSimple,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangleSimple(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
				g.scaleFactor = 2
			} else {
				g.samples = 0
				g.scaleFactor = 4
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}


	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	mainOp.GeoM.Scale(
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dx()),
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dy()),
	)

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 250, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a    float64
	specular      float32
	reflection    float32
	previousFrame *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",146.75,0.21,248.16,6.49
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3 Vector
	color      color.RGBA
	Normal     Vector
	reflection float32
	specular   float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	reflectedColor := color.RGBA{}
	if tempIntersection, reflectIntersect := reflectRay.IntersectBVH(BVH); reflectIntersect {
		reflectedColor.R = uint8(tempIntersection.Color.R)
		reflectedColor.G = uint8(tempIntersection.Color.G)
		reflectedColor.B = uint8(tempIntersection.Color.B)
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))

	var directColor color.RGBA
	if !inShadow {

		viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
		specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
		specularIntensity := light.intensity * specularFactor

		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R)+float32(intersection.Color.R))*lightIntensity*float32(light.Color[0]) +
				255*specularIntensity*float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G)+float32(intersection.Color.G))*lightIntensity*float32(light.Color[1]) +
				255*specularIntensity*float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B)+float32(intersection.Color.B))*lightIntensity*float32(light.Color[2]) +
				255*specularIntensity*float32(light.Color[2])),
			A: intersection.Color.A,
		}
	} else {
		ambientIntensity := float32(0.05)
		directColor = color.RGBA{
			R: clampUint8((float32(scatteredColor.R) + float32(intersection.Color.R)) * ambientIntensity * float32(light.Color[0])),
			G: clampUint8((float32(scatteredColor.G) + float32(intersection.Color.G)) * ambientIntensity * float32(light.Color[1])),
			B: clampUint8((float32(scatteredColor.B) + float32(intersection.Color.B)) * ambientIntensity * float32(light.Color[2])),
			A: intersection.Color.A,
		}
	}

	finalColor := color.RGBA{
		R: clampUint8(float32(directColor.R)*ratioScatterToDirect + float32(reflectedColor.R)*intersection.reflection),
		G: clampUint8(float32(directColor.G)*ratioScatterToDirect + float32(reflectedColor.G)*intersection.reflection),
		B: clampUint8(float32(directColor.B)*ratioScatterToDirect + float32(reflectedColor.B)*intersection.reflection),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]TriangleSimple
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		trianglesSimple := make([]TriangleSimple, len(triangles))
		for i, triangle := range triangles {
			trianglesSimple[i] = TriangleSimple{
				v1: triangle.v1,
				v2: triangle.v2,
				v3: triangle.v3,
				color: color.RGBA{
					R: triangle.color.R,
					G: triangle.color.G,
					B: triangle.color.B,
					A: triangle.color.A,
				},
				Normal:     triangle.Normal,
				reflection: triangle.reflection,
				specular:   triangle.specular,
			}
		}

		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &trianglesSimple,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangleSimple(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
				g.scaleFactor = 2
			} else {
				g.samples = 0
				g.scaleFactor = 4
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}


	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	mainOp.GeoM.Scale(
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dx()),
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dy()),
	)

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 250, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a    float64
	specular      float32
	reflection    float32
	previousFrame *ebiten.Image
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",206.51,0.20,258.16,17.38
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := color.RGBA{
		R: clampUint8(float32(tempIntersection.Color.R) * intersection.reflection),
		G: clampUint8(float32(tempIntersection.Color.G) * intersection.reflection),
		B: clampUint8(float32(tempIntersection.Color.B) * intersection.reflection),
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := color.RGBA{
		R: clampUint8(((float32(directReflectionColor.R+scatteredColor.R)*1 - intersection.directToScatter) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		G: clampUint8(((float32(directReflectionColor.G+scatteredColor.G)*1 - intersection.directToScatter) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		B: clampUint8(((float32(directReflectionColor.B+scatteredColor.B)*1 - intersection.directToScatter) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]TriangleSimple
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		trianglesSimple := make([]TriangleSimple, len(triangles))
		for i, triangle := range triangles {
			trianglesSimple[i] = TriangleSimple{
				v1: triangle.v1,
				v2: triangle.v2,
				v3: triangle.v3,
				color: color.RGBA{
					R: triangle.color.R,
					G: triangle.color.G,
					B: triangle.color.B,
					A: triangle.color.A,
				},
				Normal:          triangle.Normal,
				reflection:      triangle.reflection,
				specular:        triangle.specular,
				directToScatter: 0.5,
			}
		}

		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &trianglesSimple,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool , directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    18,
		indicatorHeight: 15,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/2 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/2), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, false, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangleSimple(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				triangle.directToScatter = directToScatter
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
				g.scaleFactor = 2
			} else {
				g.samples = 0
				g.scaleFactor = 4
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	mainOp.GeoM.Scale(
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dx()),
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dy()),
	)

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 250, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed , &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a    float64
	specular      float32
	reflection    float32
	previousFrame *ebiten.Image
	directToScatter float32
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",192.18,0.20,244.47,17.83
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		var uVec Vector
		if math32.Abs(intersection.Normal.x) > 0.1 {
			uVec = Vector{0.0, 1.0, 0.0}
		} else {
			uVec = Vector{1.0, 0.0, 0.0}
		}
		uVec = uVec.Cross(intersection.Normal).Normalize()
		vVec := intersection.Normal.Cross(uVec)

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))
		direction := directionLocal.Normalize()

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: direction}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := color.RGBA{
		R: clampUint8(float32(tempIntersection.Color.R) * intersection.reflection),
		G: clampUint8(float32(tempIntersection.Color.G) * intersection.reflection),
		B: clampUint8(float32(tempIntersection.Color.B) * intersection.reflection),
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := color.RGBA{
		R: clampUint8(((float32(directReflectionColor.R+scatteredColor.R)*1 - intersection.directToScatter) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		G: clampUint8(((float32(directReflectionColor.G+scatteredColor.G)*1 - intersection.directToScatter) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		B: clampUint8(((float32(directReflectionColor.B+scatteredColor.B)*1 - intersection.directToScatter) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]TriangleSimple
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		trianglesSimple := make([]TriangleSimple, len(triangles))
		for i, triangle := range triangles {
			trianglesSimple[i] = TriangleSimple{
				v1: triangle.v1,
				v2: triangle.v2,
				v3: triangle.v3,
				color: color.RGBA{
					R: triangle.color.R,
					G: triangle.color.G,
					B: triangle.color.B,
					A: triangle.color.A,
				},
				Normal:          triangle.Normal,
				reflection:      triangle.reflection,
				specular:        triangle.specular,
				directToScatter: 0.5,
			}
		}

		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &trianglesSimple,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangleSimple(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				triangle.directToScatter = directToScatter
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
				g.scaleFactor = 2
			} else {
				g.samples = 0
				g.scaleFactor = 4
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	mainOp.GeoM.Scale(
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dx()),
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dy()),
	)

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",202.62,0.21,249.19,15.48
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := color.RGBA{
		R: clampUint8(float32(tempIntersection.Color.R) * intersection.reflection),
		G: clampUint8(float32(tempIntersection.Color.G) * intersection.reflection),
		B: clampUint8(float32(tempIntersection.Color.B) * intersection.reflection),
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := color.RGBA{
		R: clampUint8(((float32(directReflectionColor.R+scatteredColor.R)*1 - intersection.directToScatter) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		G: clampUint8(((float32(directReflectionColor.G+scatteredColor.G)*1 - intersection.directToScatter) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		B: clampUint8(((float32(directReflectionColor.B+scatteredColor.B)*1 - intersection.directToScatter) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R)*intersection.directToScatter + float32(bouncedColor.R)*1 - intersection.directToScatter))
	finalColor.G = clampUint8((float32(finalColor.G)*intersection.directToScatter + float32(bouncedColor.G)*1 - intersection.directToScatter))
	finalColor.B = clampUint8((float32(finalColor.B)*intersection.directToScatter + float32(bouncedColor.B)*1 - intersection.directToScatter))

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]TriangleSimple
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		trianglesSimple := make([]TriangleSimple, len(triangles))
		for i, triangle := range triangles {
			trianglesSimple[i] = TriangleSimple{
				v1: triangle.v1,
				v2: triangle.v2,
				v3: triangle.v3,
				color: color.RGBA{
					R: triangle.color.R,
					G: triangle.color.G,
					B: triangle.color.B,
					A: triangle.color.A,
				},
				Normal:          triangle.Normal,
				reflection:      triangle.reflection,
				specular:        triangle.specular,
				directToScatter: 0.5,
			}
		}

		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &trianglesSimple,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangleSimple(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				triangle.directToScatter = directToScatter
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.samples = 2
				g.scaleFactor = 2
			} else {
				g.samples = 0
				g.scaleFactor = 4
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 300)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	DrawRays(g.camera, g.light, g.scaleFactor, g.samples, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	mainOp.GeoM.Scale(
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dx()),
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dy()),
	)

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	samples          int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 0.8}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		samples:     0,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",197.59,0.21,254.82,9.75
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox *[2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox *[2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.Triangles != nil {
			intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := color.RGBA{
		R: clampUint8(scatteredRed * ratioScatterToDirect),
		G: clampUint8(scatteredGreen * ratioScatterToDirect),
		B: clampUint8(scatteredBlue * ratioScatterToDirect),
		A: intersection.Color.A,
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := color.RGBA{
		R: clampUint8(float32(tempIntersection.Color.R) * intersection.reflection),
		G: clampUint8(float32(tempIntersection.Color.G) * intersection.reflection),
		B: clampUint8(float32(tempIntersection.Color.B) * intersection.reflection),
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := color.RGBA{
		R: clampUint8(((float32(directReflectionColor.R+scatteredColor.R)*1 - intersection.directToScatter) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		G: clampUint8(((float32(directReflectionColor.G+scatteredColor.G)*1 - intersection.directToScatter) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		B: clampUint8(((float32(directReflectionColor.B+scatteredColor.B)*1 - intersection.directToScatter) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0]),
		A: uint8(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	finalColor.R = clampUint8((float32(finalColor.R) + float32(bouncedColor.R)) / 2)
	finalColor.G = clampUint8((float32(finalColor.G) + float32(bouncedColor.G)) / 2)
	finalColor.B = clampUint8((float32(finalColor.B) + float32(bouncedColor.B)) / 2)

	return finalColor
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox *[2]Vector
	Triangles   *[]TriangleSimple
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 2 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		trianglesSimple := make([]TriangleSimple, len(triangles))
		for i, triangle := range triangles {
			trianglesSimple[i] = TriangleSimple{
				v1: triangle.v1,
				v2: triangle.v2,
				v3: triangle.v3,
				color: color.RGBA{
					R: triangle.color.R,
					G: triangle.color.G,
					B: triangle.color.B,
					A: triangle.color.A,
				},
				Normal:          triangle.Normal,
				reflection:      triangle.reflection,
				specular:        triangle.specular,
				directToScatter: 0.5,
			}
		}

		node := &BVHNode{
			BoundingBox: &boundingBox,
			Triangles:   &trianglesSimple,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: &boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.Triangles != nil {
		for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangleSimple(triangle); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				triangle.color = newColor
				triangle.reflection = reflection
				triangle.specular = specular
				triangle.directToScatter = directToScatter
				// Update the triangle in the slice
				(*node.Triangles)[i] = triangle // Dereference the pointer to modify the slice
				return true
			}
		}
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
			if fullScreen {
				g.scaleFactor = 2
			} else {
				g.scaleFactor = 4
			}
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/2)*float64(i))
		} else {
			op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		}
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}
	mainOp.GeoM.Scale(
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dx()),
		float64(screenWidth)/float64(g.currentFrame.Bounds().Dy()),
	)

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 1.5}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",201.05,0.20,253.11,16.52
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := Triangle{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					triangle.CalculateBoundingBox()
					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

func (t *Triangle) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *Triangle) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []Triangle {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []Triangle{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []Triangle{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []Triangle {
	var triangles []Triangle
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) Triangle {
	triangle := Triangle{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	type ColorRGBA_Float32 struct {
		R, G, B, A float32
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorRGBA_Float32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorRGBA_Float32{
		R: float32(tempIntersection.Color.R) * intersection.reflection,
		G: float32(tempIntersection.Color.G) * intersection.reflection,
		B: float32(tempIntersection.Color.B) * intersection.reflection,
		A: float32(intersection.Color.A),
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := ColorRGBA_Float32{
		R: ((float32(directReflectionColor.R+scatteredColor.R) * (1 - intersection.directToScatter)) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		G: ((float32(directReflectionColor.G+scatteredColor.G) * (1 - intersection.directToScatter)) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		B: ((float32(directReflectionColor.B+scatteredColor.B) * (1 - intersection.directToScatter)) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := color.RGBA{
		R: clampUint8((finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter)))),
		G: clampUint8((finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter)))),
		B: clampUint8((finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter)))),
		A: uint8(finalColor.A),
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []Triangle
	BoundingBox [2]Vector
}

var triangles []Triangle

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	for _, object := range objects {
		triangles = append(triangles, object.triangles...)
	}
	return buildBVHNode(triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active	  bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []Triangle, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		boundingBox[0].x = math32.Min(boundingBox[0].x, triangle.BoundingBox[0].x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, triangle.BoundingBox[0].y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, triangle.BoundingBox[0].z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, triangle.BoundingBox[1].x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, triangle.BoundingBox[1].y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, triangle.BoundingBox[1].z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles:   TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: color.RGBA{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				leftBBox[0].x = math32.Min(leftBBox[0].x, triangles[j].BoundingBox[0].x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, triangles[j].BoundingBox[0].y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, triangles[j].BoundingBox[0].z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, triangles[j].BoundingBox[1].x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, triangles[j].BoundingBox[1].y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			for j := i; j < len(triangles); j++ {
				rightBBox[0].x = math32.Min(rightBBox[0].x, triangles[j].BoundingBox[0].x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, triangles[j].BoundingBox[0].y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, triangles[j].BoundingBox[0].z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, triangles[j].BoundingBox[1].x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, triangles[j].BoundingBox[1].y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, triangles[j].BoundingBox[1].z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []Triangle) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, triangle.BoundingBox[0].x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, triangle.BoundingBox[0].y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, triangle.BoundingBox[0].z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, triangle.BoundingBox[1].x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, triangle.BoundingBox[1].y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, triangle.BoundingBox[1].z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []Triangle {
	triangles := []Triangle{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
			if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
				// fmt.Println(""Triangle hit"", triangle.color)
				NewTriangle := TriangleSimple{
					v1: node.Triangles.v1,
					v2: node.Triangles.v2,
					v3: node.Triangles.v3,
					color: color.RGBA{
						R: uint8(newColor.R),
						G: uint8(newColor.G),
						B: uint8(newColor.B),
						A: uint8(newColor.A),
					},
					Normal:          node.Triangles.Normal,
					reflection:      reflection,
					specular:        specular,
					directToScatter: directToScatter,
				}
				node.Triangles = NewTriangle
				return true
			}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
			if screenResolution.Selected == 0 {
				g.scaleFactor = 1
			}
			g.scaleFactor = screenResolution.Selected * 2
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 1.5}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",191.75,0.21,238.27,17.62
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := TriangleSimple{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

type Triangle struct {
	v1, v2, v3  Vector
	color       color.RGBA
	BoundingBox [2]Vector
	Normal      Vector
	reflection  float32
	specular    float32
}

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

func (t *TriangleSimple) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *TriangleSimple) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []TriangleSimple {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []TriangleSimple{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []TriangleSimple {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []TriangleSimple{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []TriangleSimple {
	var triangles []TriangleSimple
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

func (triangle *Triangle) CalculateBoundingBox() {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
}

func (triangle TriangleSimple) CalculateBoundingBox() (minBox Vector, maxBox Vector) {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	return Vector{minX, minY, minZ}, Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) TriangleSimple {
	triangle := TriangleSimple{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular, directToScatter: 0.5}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	return tmax >= max(0.0, tmin)
}

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
	// Check if the ray intersects the bounding box of the triangle first
	if !triangle.IntersectBoundingBox(*ray) {
		return Intersection{}, false
	}

	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
	}
	return Intersection{}, false
}

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Check if the ray intersects the bounding box of the triangle first
		if !triangle.IntersectBoundingBox(ray) {
			continue
		}

		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	type ColorRGBA_Float32 struct {
		R, G, B, A float32
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorRGBA_Float32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorRGBA_Float32{
		R: float32(tempIntersection.Color.R) * intersection.reflection,
		G: float32(tempIntersection.Color.G) * intersection.reflection,
		B: float32(tempIntersection.Color.B) * intersection.reflection,
		A: float32(intersection.Color.A),
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := ColorRGBA_Float32{
		R: ((float32(directReflectionColor.R+scatteredColor.R) * (1 - intersection.directToScatter)) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		G: ((float32(directReflectionColor.G+scatteredColor.G) * (1 - intersection.directToScatter)) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		B: ((float32(directReflectionColor.B+scatteredColor.B) * (1 - intersection.directToScatter)) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := color.RGBA{
		R: clampUint8((finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter)))),
		G: clampUint8((finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter)))),
		B: clampUint8((finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter)))),
		A: uint8(finalColor.A),
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []TriangleSimple
	BoundingBox [2]Vector
}

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	Triangles := []TriangleSimple{}
	for _, object := range objects {
		Triangles = append(Triangles, object.triangles...)
	}
	return buildBVHNode(Triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active      bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []TriangleSimple, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		minBox, maxBox := triangle.CalculateBoundingBox()
		boundingBox[0].x = math32.Min(boundingBox[0].x, minBox.x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, minBox.y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, minBox.z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, maxBox.x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, maxBox.y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, maxBox.z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles: TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: color.RGBA{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.x < jMinBox.x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.y < jMinBox.y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.z < jMinBox.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				leftBBox[0].x = math32.Min(leftBBox[0].x, jMinBox.x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, jMinBox.y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, jMinBox.z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, jMaxBox.x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, jMaxBox.y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, jMaxBox.z)
			}

			for j := i; j < len(triangles); j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				rightBBox[0].x = math32.Min(rightBBox[0].x, jMinBox.x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, jMinBox.y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, jMinBox.z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, jMaxBox.x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, jMaxBox.y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, jMaxBox.z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			return iMinBox.x < jMinBox.x
			// return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			return iMinBox.y < jMinBox.y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			return iMinBox.z < jMinBox.z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []TriangleSimple) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		minBox , maxBox := triangle.CalculateBoundingBox()
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, minBox.x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, minBox.y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, minBox.z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, maxBox.x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, maxBox.y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, maxBox.z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []TriangleSimple {
	triangles := []TriangleSimple{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
		if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
			// fmt.Println(""Triangle hit"", triangle.color)
			NewTriangle := TriangleSimple{
				v1: node.Triangles.v1,
				v2: node.Triangles.v2,
				v3: node.Triangles.v3,
				color: color.RGBA{
					R: uint8(newColor.R),
					G: uint8(newColor.G),
					B: uint8(newColor.B),
					A: uint8(newColor.A),
				},
				Normal:          node.Triangles.Normal,
				reflection:      reflection,
				specular:        specular,
				directToScatter: directToScatter,
			}
			node.Triangles = NewTriangle
			return true
		}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
			if screenResolution.Selected == 0 {
				g.scaleFactor = 1
			}
			g.scaleFactor = screenResolution.Selected * 2
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 1.5}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",192.38,0.05,237.43,18.89
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := TriangleSimple{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

type Ray struct {
	origin, direction Vector
}

// type Triangle struct {
// 	v1, v2, v3  Vector
// 	color       color.RGBA
// 	BoundingBox [2]Vector
// 	Normal      Vector
// 	reflection  float32
// 	specular    float32
// }

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

func (t *TriangleSimple) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray *Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *TriangleSimple) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []TriangleSimple {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []TriangleSimple{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []TriangleSimple {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []TriangleSimple{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []TriangleSimple {
	var triangles []TriangleSimple
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

// func (triangle *Triangle) CalculateBoundingBox() {
// 	// Compute the minimum and maximum coordinates using float32 functions
// 	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
// 	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
// 	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
// 	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
// 	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
// 	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

// 	// Set the BoundingBox with computed min and max values
// 	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
// 	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
// }

func (triangle TriangleSimple) CalculateBoundingBox() (minBox Vector, maxBox Vector) {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	return Vector{minX, minY, minZ}, Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) TriangleSimple {
	triangle := TriangleSimple{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular, directToScatter: 0.5}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

// func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
// 	// Precompute the inverse direction
// 	invDirX := 1.0 / ray.direction.x
// 	invDirY := 1.0 / ray.direction.y
// 	invDirZ := 1.0 / ray.direction.z

// 	// Compute the tmin and tmax for each axis directly
// 	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
// 	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
// 	tmin := min(tx1, tx2)
// 	tmax := max(tx1, tx2)

// 	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
// 	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
// 	tmin = max(tmin, min(ty1, ty2))
// 	tmax = min(tmax, max(ty1, ty2))

// 	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
// 	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
// 	tmin = max(tmin, min(tz1, tz2))
// 	tmax = min(tmax, max(tz1, tz2))

// 	// Final intersection check
// 	return tmax >= max(0.0, tmin)
// }

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

// func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
// 	// Check if the ray intersects the bounding box of the triangle first
// 	if !triangle.IntersectBoundingBox(*ray) {
// 		return Intersection{}, false
// 	}

// 	// Möller–Trumbore intersection algorithm
// 	edge1 := triangle.v2.Sub(triangle.v1)
// 	edge2 := triangle.v3.Sub(triangle.v1)
// 	h := ray.direction.Cross(edge2)
// 	a := edge1.Dot(h)
// 	if a > -0.00001 && a < 0.00001 {
// 		return Intersection{}, false
// 	}
// 	f := 1.0 / a
// 	s := ray.origin.Sub(triangle.v1)
// 	u := f * s.Dot(h)
// 	if u < 0.0 || u > 1.0 {
// 		return Intersection{}, false
// 	}
// 	q := s.Cross(edge1)
// 	v := f * ray.direction.Dot(q)
// 	if v < 0.0 || u+v > 1.0 {
// 		return Intersection{}, false
// 	}
// 	t := f * edge2.Dot(q)
// 	if t > 0.00001 {
// 		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
// 	}
// 	return Intersection{}, false
// }

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

// func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
// 	// Initialize the closest intersection and hit status
// 	closestIntersection := Intersection{Distance: math32.MaxFloat32}
// 	hasIntersection := false

// 	// Iterate over each triangle for the given ray
// 	for _, triangle := range triangles {
// 		// Check if the ray intersects the bounding box of the triangle first
// 		if !triangle.IntersectBoundingBox(ray) {
// 			continue
// 		}

// 		// Möller–Trumbore intersection algorithm
// 		edge1 := triangle.v2.Sub(triangle.v1)
// 		edge2 := triangle.v3.Sub(triangle.v1)
// 		h := ray.direction.Cross(edge2)
// 		a := edge1.Dot(h)
// 		if a > -0.00001 && a < 0.00001 {
// 			continue
// 		}
// 		f := 1.0 / a
// 		s := ray.origin.Sub(triangle.v1)
// 		u := f * s.Dot(h)
// 		if u < 0.0 || u > 1.0 {
// 			continue
// 		}
// 		q := s.Cross(edge1)
// 		v := f * ray.direction.Dot(q)
// 		if v < 0.0 || u+v > 1.0 {
// 			continue
// 		}
// 		t := f * edge2.Dot(q)
// 		if t > 0.00001 {
// 			tempIntersection := Intersection{
// 				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
// 				Color:               triangle.color,
// 				Normal:              triangle.Normal,
// 				Direction:           ray.direction,
// 				Distance:            t,
// 				reflection:          triangle.reflection,
// 				specular:            triangle.specular,
// 			}

// 			// Update the closest intersection if the new one is closer
// 			if t < closestIntersection.Distance {
// 				closestIntersection = tempIntersection
// 				hasIntersection = true
// 			}
// 		}
// 	}

// 	return closestIntersection, hasIntersection
// }

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	type ColorRGBA_Float32 struct {
		R, G, B, A float32
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorRGBA_Float32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := intersection.Normal.Mul(2 * lightDir.Dot(intersection.Normal)).Sub(lightDir).Normalize()

	reflectRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorRGBA_Float32{
		R: float32(tempIntersection.Color.R) * intersection.reflection,
		G: float32(tempIntersection.Color.G) * intersection.reflection,
		B: float32(tempIntersection.Color.B) * intersection.reflection,
		A: float32(intersection.Color.A),
	}

	shadowRay := Ray{
		origin:    intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)),
		direction: light.Position.Sub(intersection.PointOfIntersection).Normalize(),
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := ColorRGBA_Float32{
		R: ((float32(directReflectionColor.R+scatteredColor.R) * (1 - intersection.directToScatter)) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		G: ((float32(directReflectionColor.G+scatteredColor.G) * (1 - intersection.directToScatter)) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		B: ((float32(directReflectionColor.B+scatteredColor.B) * (1 - intersection.directToScatter)) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := color.RGBA{
		R: clampUint8((finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter)))),
		G: clampUint8((finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter)))),
		B: clampUint8((finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter)))),
		A: uint8(finalColor.A),
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []TriangleSimple
	BoundingBox [2]Vector
}

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	Triangles := []TriangleSimple{}
	for _, object := range objects {
		Triangles = append(Triangles, object.triangles...)
	}
	return buildBVHNode(Triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active      bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []TriangleSimple, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		minBox, maxBox := triangle.CalculateBoundingBox()
		boundingBox[0].x = math32.Min(boundingBox[0].x, minBox.x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, minBox.y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, minBox.z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, maxBox.x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, maxBox.y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, maxBox.z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles: TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: color.RGBA{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.x < jMinBox.x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.y < jMinBox.y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.z < jMinBox.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				leftBBox[0].x = math32.Min(leftBBox[0].x, jMinBox.x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, jMinBox.y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, jMinBox.z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, jMaxBox.x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, jMaxBox.y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, jMaxBox.z)
			}

			for j := i; j < len(triangles); j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				rightBBox[0].x = math32.Min(rightBBox[0].x, jMinBox.x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, jMinBox.y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, jMinBox.z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, jMaxBox.x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, jMaxBox.y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, jMaxBox.z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			return iMinBox.x < jMinBox.x
			// return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			return iMinBox.y < jMinBox.y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			return iMinBox.z < jMinBox.z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []TriangleSimple) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		minBox , maxBox := triangle.CalculateBoundingBox()
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, minBox.x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, minBox.y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, minBox.z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, maxBox.x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, maxBox.y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, maxBox.z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []TriangleSimple {
	triangles := []TriangleSimple{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
		if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
			// fmt.Println(""Triangle hit"", triangle.color)
			NewTriangle := TriangleSimple{
				v1: node.Triangles.v1,
				v2: node.Triangles.v2,
				v3: node.Triangles.v3,
				color: color.RGBA{
					R: uint8(newColor.R),
					G: uint8(newColor.G),
					B: uint8(newColor.B),
					A: uint8(newColor.A),
				},
				Normal:          node.Triangles.Normal,
				reflection:      reflection,
				specular:        specular,
				directToScatter: directToScatter,
			}
			node.Triangles = NewTriangle
			return true
		}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
			if screenResolution.Selected == 0 {
				g.scaleFactor = 1
			}
			g.scaleFactor = screenResolution.Selected * 2
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

var subImageHeight int
var subImageWidth int
var fullScreen = false
var startTime time.Time

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 1.5}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	subImageHeight = screenHeight / numCPU / scale
	subImageWidth = screenWidth / scale

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",190.15,0.05,237.21,15.84
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color color.RGBA
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = color.RGBA{
				R: uint8(r * 255),
				G: uint8(g * 255),
				B: uint8(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := TriangleSimple{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						triangle.color = color.RGBA{255, 125, 0, 255} // Default color
					}

					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

func (v Vector) Reflect(normal Vector) Vector {
	return v.Sub(normal.Mul(2 * v.Dot(normal)))
}

type Ray struct {
	origin, direction Vector
}

// type Triangle struct {
// 	v1, v2, v3  Vector
// 	color       color.RGBA
// 	BoundingBox [2]Vector
// 	Normal      Vector
// 	reflection  float32
// 	specular    float32
// }

type TriangleSimple struct {
	v1, v2, v3      Vector
	color           color.RGBA
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

type SphereSimple struct {
	center Vector
	radius float32
	color  color.RGBA
}

func Distance(v1, v2 Vector, radius float32) float32 {
	// Use vector subtraction and dot product instead of individual calculations
	diff := v1.Sub(v2)
	return diff.Length() - radius
}

// Add normal calculation for spheres
func calculateNormal(point, center Vector) Vector {
	return point.Sub(center).Normalize()
}

// Improved sphere conversion with pre-allocated slice
func (obj object) ConvertToSquare(count int) []SphereSimple {
	spheres := make([]SphereSimple, 0, count)

	for i := 0; i < count; i += 1 {
		randIndex := rand.Intn(len(obj.triangles))
		spheres = append(spheres, SphereSimple{
			center: obj.triangles[randIndex].v1,
			radius: 2,
			color:  obj.triangles[randIndex].color,
		})
	}
	return spheres
}

func RayMarching(ray Ray, spheres []SphereSimple, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
		MIN_DISTANCE = float32(0.0)
	)

	var (
		totalDistance float32
		sphereColor   = color.RGBA{0, 0, 0, 255}
		closestSphere SphereSimple
		currentPoint  Vector
	)

	// Early exit if no spheres
	if len(spheres) == 0 {
		return sphereColor, totalDistance
	}

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		// Find closest sphere
		for _, sphere := range spheres {
			if dist := Distance(currentPoint, sphere.center, sphere.radius); dist < minDistance {
				minDistance = dist
				closestSphere = sphere
			}
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

// Helper function for color shading calculations
func calculateShading(point Vector, sphere SphereSimple, totalDistance, maxDistance float32, light Light) color.RGBA {

	// Calculate normal at intersection point
	normal := calculateNormal(point, sphere.center)

	// Calculate light direction
	lightDir := light.Position.Sub(point).Normalize()

	// Ambient component
	ambientStrength := float32(0.1)
	ambient := float32(sphere.color.R) * ambientStrength

	// Diffuse component
	diff := max(normal.Dot(lightDir), 0.0)
	diffuse := diff * float32(sphere.color.R)

	// Specular component
	specularStrength := float32(0.5)
	viewDir := point.Mul(-1).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(normal)
	spec := math32.Pow(max(viewDir.Dot(reflectDir), 0.0), 32)
	specular := specularStrength * spec

	// Distance attenuation
	// attenuation := maxDistance / totalDistance

	// Combine components
	final := min((ambient + diffuse + specular), 255)

	return color.RGBA{
		R: uint8(final / 255 * float32(sphere.color.R)),
		G: uint8(final / 255 * float32(sphere.color.G)),
		B: uint8(final / 255 * float32(sphere.color.B)),
		A: 255,
	}
}

func (t *TriangleSimple) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *TriangleSimple) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color color.RGBA, refection float32, specular float32) []TriangleSimple {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []TriangleSimple{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color color.RGBA, reflection float32, specular float32) []TriangleSimple {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []TriangleSimple{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color color.RGBA, reflection float32, specular float32) []TriangleSimple {
	var triangles []TriangleSimple
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

// func (triangle *Triangle) CalculateBoundingBox() {
// 	// Compute the minimum and maximum coordinates using float32 functions
// 	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
// 	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
// 	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
// 	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
// 	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
// 	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

// 	// Set the BoundingBox with computed min and max values
// 	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
// 	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
// }

func (triangle TriangleSimple) CalculateBoundingBox() (minBox Vector, maxBox Vector) {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	return Vector{minX, minY, minZ}, Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color color.RGBA, reflection float32, specular float32) TriangleSimple {
	triangle := TriangleSimple{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular, directToScatter: 0.5}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

// func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
// 	// Precompute the inverse direction
// 	invDirX := 1.0 / ray.direction.x
// 	invDirY := 1.0 / ray.direction.y
// 	invDirZ := 1.0 / ray.direction.z

// 	// Compute the tmin and tmax for each axis directly
// 	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
// 	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
// 	tmin := min(tx1, tx2)
// 	tmax := max(tx1, tx2)

// 	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
// 	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
// 	tmin = max(tmin, min(ty1, ty2))
// 	tmax = min(tmax, max(ty1, ty2))

// 	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
// 	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
// 	tmin = max(tmin, min(tz1, tz2))
// 	tmax = min(tmax, max(tz1, tz2))

// 	// Final intersection check
// 	return tmax >= max(0.0, tmin)
// }

type Intersection struct {
	PointOfIntersection Vector
	Color               color.RGBA
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

// func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
// 	// Check if the ray intersects the bounding box of the triangle first
// 	if !triangle.IntersectBoundingBox(*ray) {
// 		return Intersection{}, false
// 	}

// 	// Möller–Trumbore intersection algorithm
// 	edge1 := triangle.v2.Sub(triangle.v1)
// 	edge2 := triangle.v3.Sub(triangle.v1)
// 	h := ray.direction.Cross(edge2)
// 	a := edge1.Dot(h)
// 	if a > -0.00001 && a < 0.00001 {
// 		return Intersection{}, false
// 	}
// 	f := 1.0 / a
// 	s := ray.origin.Sub(triangle.v1)
// 	u := f * s.Dot(h)
// 	if u < 0.0 || u > 1.0 {
// 		return Intersection{}, false
// 	}
// 	q := s.Cross(edge1)
// 	v := f * ray.direction.Dot(q)
// 	if v < 0.0 || u+v > 1.0 {
// 		return Intersection{}, false
// 	}
// 	t := f * edge2.Dot(q)
// 	if t > 0.00001 {
// 		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
// 	}
// 	return Intersection{}, false
// }

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

// func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
// 	// Initialize the closest intersection and hit status
// 	closestIntersection := Intersection{Distance: math32.MaxFloat32}
// 	hasIntersection := false

// 	// Iterate over each triangle for the given ray
// 	for _, triangle := range triangles {
// 		// Check if the ray intersects the bounding box of the triangle first
// 		if !triangle.IntersectBoundingBox(ray) {
// 			continue
// 		}

// 		// Möller–Trumbore intersection algorithm
// 		edge1 := triangle.v2.Sub(triangle.v1)
// 		edge2 := triangle.v3.Sub(triangle.v1)
// 		h := ray.direction.Cross(edge2)
// 		a := edge1.Dot(h)
// 		if a > -0.00001 && a < 0.00001 {
// 			continue
// 		}
// 		f := 1.0 / a
// 		s := ray.origin.Sub(triangle.v1)
// 		u := f * s.Dot(h)
// 		if u < 0.0 || u > 1.0 {
// 			continue
// 		}
// 		q := s.Cross(edge1)
// 		v := f * ray.direction.Dot(q)
// 		if v < 0.0 || u+v > 1.0 {
// 			continue
// 		}
// 		t := f * edge2.Dot(q)
// 		if t > 0.00001 {
// 			tempIntersection := Intersection{
// 				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
// 				Color:               triangle.color,
// 				Normal:              triangle.Normal,
// 				Direction:           ray.direction,
// 				Distance:            t,
// 				reflection:          triangle.reflection,
// 				specular:            triangle.specular,
// 			}

// 			// Update the closest intersection if the new one is closer
// 			if t < closestIntersection.Distance {
// 				closestIntersection = tempIntersection
// 				hasIntersection = true
// 			}
// 		}
// 	}

// 	return closestIntersection, hasIntersection
// }

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) color.RGBA {
	if depth == 0 {
		return color.RGBA{}
	}

	type ColorRGBA_Float32 struct {
		R, G, B, A float32
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return color.RGBA{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorRGBA_Float32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(intersection.Normal)

	reflectRayOrigin := intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001))

	reflectRay := Ray{origin: reflectRayOrigin, direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorRGBA_Float32{
		R: float32(tempIntersection.Color.R) * intersection.reflection,
		G: float32(tempIntersection.Color.G) * intersection.reflection,
		B: float32(tempIntersection.Color.B) * intersection.reflection,
		A: float32(intersection.Color.A),
	}

	shadowRay := Ray{
		origin:    reflectRayOrigin,
		direction: lightDir,
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := ColorRGBA_Float32{
		R: ((float32(directReflectionColor.R+scatteredColor.R) * (1 - intersection.directToScatter)) + (float32(intersection.Color.R) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		G: ((float32(directReflectionColor.G+scatteredColor.G) * (1 - intersection.directToScatter)) + (float32(intersection.Color.G) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		B: ((float32(directReflectionColor.B+scatteredColor.B) * (1 - intersection.directToScatter)) + (float32(intersection.Color.B) * intersection.directToScatter) + (specularIntensity * float32(light.Color[0]))) * lightIntensity * light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: reflectRayOrigin, direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := color.RGBA{
		R: clampUint8((finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter)))),
		G: clampUint8((finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter)))),
		B: clampUint8((finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter)))),
		A: uint8(finalColor.A),
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []TriangleSimple
	BoundingBox [2]Vector
}

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	Triangles := []TriangleSimple{}
	for _, object := range objects {
		Triangles = append(Triangles, object.triangles...)
	}
	return buildBVHNode(Triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active      bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []TriangleSimple, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		minBox, maxBox := triangle.CalculateBoundingBox()
		boundingBox[0].x = math32.Min(boundingBox[0].x, minBox.x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, minBox.y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, minBox.z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, maxBox.x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, maxBox.y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, maxBox.z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles: TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: color.RGBA{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.x < jMinBox.x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.y < jMinBox.y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.z < jMinBox.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				leftBBox[0].x = math32.Min(leftBBox[0].x, jMinBox.x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, jMinBox.y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, jMinBox.z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, jMaxBox.x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, jMaxBox.y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, jMaxBox.z)
			}

			for j := i; j < len(triangles); j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				rightBBox[0].x = math32.Min(rightBBox[0].x, jMinBox.x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, jMinBox.y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, jMinBox.z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, jMaxBox.x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, jMaxBox.y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, jMaxBox.z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			return iMinBox.x < jMinBox.x
			// return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			return iMinBox.y < jMinBox.y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			return iMinBox.z < jMinBox.z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []TriangleSimple) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		minBox, maxBox := triangle.CalculateBoundingBox()
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, minBox.x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, minBox.y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, minBox.z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, maxBox.x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, maxBox.y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, maxBox.z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := color.RGBA{uint8(rand.Intn(255)), uint8(rand.Intn(255)), uint8(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []TriangleSimple {
	triangles := []TriangleSimple{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

func DrawSpheres(spheres []SphereSimple, camera Camera, scaling int, iterations int, subImages []*ebiten.Image, light Light) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c, _ := RayMarching(Ray{origin: camera.Position, direction: rayDir}, spheres, iterations, light)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor color.RGBA, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
		if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
			// fmt.Println(""Triangle hit"", triangle.color)
			NewTriangle := TriangleSimple{
				v1: node.Triangles.v1,
				v2: node.Triangles.v2,
				v3: node.Triangles.v3,
				color: color.RGBA{
					R: uint8(newColor.R),
					G: uint8(newColor.G),
					B: uint8(newColor.B),
					A: uint8(newColor.A),
				},
				Normal:          node.Triangles.Normal,
				reflection:      reflection,
				specular:        specular,
				directToScatter: directToScatter,
			}
			node.Triangles = NewTriangle
			return true
		}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, color.RGBA{uint8(g.r * 255), uint8(g.g * 255), uint8(g.b * 255), uint8(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	if !Benchmark {
		DrawSpheres(g.Spheres, g.camera, g.scaleFactor, 32, g.subImages, g.light)
		for i, subImage := range g.subImages {
			op := &ebiten.DrawImageOptions{}
			// if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
			// } else {
			// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
			// }
			g.currentFrame.DrawImage(subImage, op)
		}
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
			if screenResolution.Selected == 0 {
				g.scaleFactor = 1
			}
			g.scaleFactor = screenResolution.Selected * 2
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	Spheres         []SphereSimple
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

const subImageHeight = screenHeight / numCPU / 2
const subImageWidth = screenWidth

var fullScreen = false
var startTime time.Time

var Spheres = []SphereSimple{}

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 1.5}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	Spheres = obj.ConvertToSquare(32)

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),

		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",190.01,0.05,235.47,14.70
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color ColorFloat32
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = ColorFloat32{
				R: float32(r * 255),
				G: float32(g * 255),
				B: float32(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := TriangleSimple{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						// triangle.color = color.RGBA{255, 125, 0, 255} // Default color
						triangle.color = ColorFloat32{255, 125, 0, 255} // Default color
					}

					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

func (v Vector) Reflect(normal Vector) Vector {
	return v.Sub(normal.Mul(2 * v.Dot(normal)))
}

type Ray struct {
	origin, direction Vector
}

//	type Triangle struct {
//		v1, v2, v3  Vector
//		color       color.RGBA
//		BoundingBox [2]Vector
//		Normal      Vector
//		reflection  float32
//		specular    float32
//	}

type ColorFloat32 struct {
	R, G, B, A float32
}

type TriangleSimple struct {
	v1, v2, v3 Vector
	// color           color.RGBA
	color           ColorFloat32
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

type SphereSimple struct {
	center Vector
	radius float32
	color  color.RGBA
}

func Distance(v1, v2 Vector, radius float32) float32 {
	// Use vector subtraction and dot product instead of individual calculations
	diff := v1.Sub(v2)
	return diff.Length() - radius
}

// Add normal calculation for spheres
func calculateNormal(point, center Vector) Vector {
	return point.Sub(center).Normalize()
}

func clampInt(value int) uint8 {
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// Improved sphere conversion with pre-allocated slice
func (obj object) ConvertToSquare(count int) []SphereSimple {
	spheres := make([]SphereSimple, 0, count)

	for i := 0; i < count; i += 1 {
		randIndex := rand.Intn(len(obj.triangles))
		R := clampUint8(obj.triangles[randIndex].color.R)
		G := clampUint8(obj.triangles[randIndex].color.G)
		B := clampUint8(obj.triangles[randIndex].color.B)
		spheres = append(spheres, SphereSimple{
			center: obj.triangles[randIndex].v1,
			radius: 2,
			// color:  obj.triangles[randIndex].color,
			color: color.RGBA{R, G, B, 255},
		})
	}
	return spheres
}

func RayMarching(ray Ray, spheres []SphereSimple, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
		MIN_DISTANCE = float32(0.0)
	)

	var (
		totalDistance float32
		sphereColor   = color.RGBA{0, 0, 0, 255}
		closestSphere SphereSimple
		currentPoint  Vector
	)

	// Early exit if no spheres
	if len(spheres) == 0 {
		return sphereColor, totalDistance
	}

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		// Find closest sphere
		for _, sphere := range spheres {
			if dist := Distance(currentPoint, sphere.center, sphere.radius); dist < minDistance {
				minDistance = dist
				closestSphere = sphere
			}
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

// Helper function for color shading calculations
func calculateShading(point Vector, sphere SphereSimple, totalDistance, maxDistance float32, light Light) color.RGBA {

	// Calculate normal at intersection point
	normal := calculateNormal(point, sphere.center)

	// Calculate light direction
	lightDir := light.Position.Sub(point).Normalize()

	// Ambient component
	ambientStrength := float32(0.1)
	ambient := float32(sphere.color.R) * ambientStrength

	// Diffuse component
	diff := max(normal.Dot(lightDir), 0.0)
	diffuse := diff * float32(sphere.color.R)

	// Specular component
	specularStrength := float32(0.5)
	viewDir := point.Mul(-1).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(normal)
	spec := math32.Pow(max(viewDir.Dot(reflectDir), 0.0), 32)
	specular := specularStrength * spec

	// Distance attenuation
	// attenuation := maxDistance / totalDistance

	// Combine components
	final := min((ambient + diffuse + specular), 255)

	return color.RGBA{
		R: uint8(final / 255 * float32(sphere.color.R)),
		G: uint8(final / 255 * float32(sphere.color.G)),
		B: uint8(final / 255 * float32(sphere.color.B)),
		A: 255,
	}
}

func (t *TriangleSimple) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *TriangleSimple) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color ColorFloat32, refection float32, specular float32) []TriangleSimple {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []TriangleSimple{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []TriangleSimple{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	var triangles []TriangleSimple
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

// func (triangle *Triangle) CalculateBoundingBox() {
// 	// Compute the minimum and maximum coordinates using float32 functions
// 	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
// 	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
// 	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
// 	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
// 	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
// 	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

// 	// Set the BoundingBox with computed min and max values
// 	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
// 	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
// }

func (triangle TriangleSimple) CalculateBoundingBox() (minBox Vector, maxBox Vector) {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	return Vector{minX, minY, minZ}, Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color ColorFloat32, reflection float32, specular float32) TriangleSimple {
	triangle := TriangleSimple{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular, directToScatter: 0.5}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

// func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
// 	// Precompute the inverse direction
// 	invDirX := 1.0 / ray.direction.x
// 	invDirY := 1.0 / ray.direction.y
// 	invDirZ := 1.0 / ray.direction.z

// 	// Compute the tmin and tmax for each axis directly
// 	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
// 	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
// 	tmin := min(tx1, tx2)
// 	tmax := max(tx1, tx2)

// 	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
// 	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
// 	tmin = max(tmin, min(ty1, ty2))
// 	tmax = min(tmax, max(ty1, ty2))

// 	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
// 	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
// 	tmin = max(tmin, min(tz1, tz2))
// 	tmax = min(tmax, max(tz1, tz2))

// 	// Final intersection check
// 	return tmax >= max(0.0, tmin)
// }

type Intersection struct {
	PointOfIntersection Vector
	Color               ColorFloat32
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

// func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
// 	// Check if the ray intersects the bounding box of the triangle first
// 	if !triangle.IntersectBoundingBox(*ray) {
// 		return Intersection{}, false
// 	}

// 	// Möller–Trumbore intersection algorithm
// 	edge1 := triangle.v2.Sub(triangle.v1)
// 	edge2 := triangle.v3.Sub(triangle.v1)
// 	h := ray.direction.Cross(edge2)
// 	a := edge1.Dot(h)
// 	if a > -0.00001 && a < 0.00001 {
// 		return Intersection{}, false
// 	}
// 	f := 1.0 / a
// 	s := ray.origin.Sub(triangle.v1)
// 	u := f * s.Dot(h)
// 	if u < 0.0 || u > 1.0 {
// 		return Intersection{}, false
// 	}
// 	q := s.Cross(edge1)
// 	v := f * ray.direction.Dot(q)
// 	if v < 0.0 || u+v > 1.0 {
// 		return Intersection{}, false
// 	}
// 	t := f * edge2.Dot(q)
// 	if t > 0.00001 {
// 		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
// 	}
// 	return Intersection{}, false
// }

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

// func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
// 	// Initialize the closest intersection and hit status
// 	closestIntersection := Intersection{Distance: math32.MaxFloat32}
// 	hasIntersection := false

// 	// Iterate over each triangle for the given ray
// 	for _, triangle := range triangles {
// 		// Check if the ray intersects the bounding box of the triangle first
// 		if !triangle.IntersectBoundingBox(ray) {
// 			continue
// 		}

// 		// Möller–Trumbore intersection algorithm
// 		edge1 := triangle.v2.Sub(triangle.v1)
// 		edge2 := triangle.v3.Sub(triangle.v1)
// 		h := ray.direction.Cross(edge2)
// 		a := edge1.Dot(h)
// 		if a > -0.00001 && a < 0.00001 {
// 			continue
// 		}
// 		f := 1.0 / a
// 		s := ray.origin.Sub(triangle.v1)
// 		u := f * s.Dot(h)
// 		if u < 0.0 || u > 1.0 {
// 			continue
// 		}
// 		q := s.Cross(edge1)
// 		v := f * ray.direction.Dot(q)
// 		if v < 0.0 || u+v > 1.0 {
// 			continue
// 		}
// 		t := f * edge2.Dot(q)
// 		if t > 0.00001 {
// 			tempIntersection := Intersection{
// 				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
// 				Color:               triangle.color,
// 				Normal:              triangle.Normal,
// 				Direction:           ray.direction,
// 				Distance:            t,
// 				reflection:          triangle.reflection,
// 				specular:            triangle.specular,
// 			}

// 			// Update the closest intersection if the new one is closer
// 			if t < closestIntersection.Distance {
// 				closestIntersection = tempIntersection
// 				hasIntersection = true
// 			}
// 		}
// 	}

// 	return closestIntersection, hasIntersection
// }

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) ColorFloat32 {
	if depth == 0 {
		return ColorFloat32{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return ColorFloat32{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorFloat32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(intersection.Normal)

	reflectRayOrigin := intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001))

	reflectRay := Ray{origin: reflectRayOrigin, direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorFloat32{
		R: tempIntersection.Color.R * intersection.reflection,
		G: tempIntersection.Color.G * intersection.reflection,
		B: tempIntersection.Color.B * intersection.reflection,
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    reflectRayOrigin,
		direction: lightDir,
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity float32
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	} else {
		lightIntensity = 0.05
	}

	finalColor := ColorFloat32{
		R: ((directReflectionColor.R + scatteredColor.R) * (1 - intersection.directToScatter)) + ((intersection.Color.R) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		G: ((directReflectionColor.G + scatteredColor.G) * (1 - intersection.directToScatter)) + ((intersection.Color.G) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		B: ((directReflectionColor.B + scatteredColor.B) * (1 - intersection.directToScatter)) + ((intersection.Color.B) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: reflectRayOrigin, direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := ColorFloat32{
		R: (finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter))),
		G: (finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter))),
		B: (finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter))),
		A: finalColor.A,
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []TriangleSimple
	BoundingBox [2]Vector
}

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	Triangles := []TriangleSimple{}
	for _, object := range objects {
		Triangles = append(Triangles, object.triangles...)
	}
	return buildBVHNode(Triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active      bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []TriangleSimple, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		minBox, maxBox := triangle.CalculateBoundingBox()
		boundingBox[0].x = math32.Min(boundingBox[0].x, minBox.x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, minBox.y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, minBox.z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, maxBox.x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, maxBox.y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, maxBox.z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles: TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: ColorFloat32{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.x < jMinBox.x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.y < jMinBox.y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.z < jMinBox.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				leftBBox[0].x = math32.Min(leftBBox[0].x, jMinBox.x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, jMinBox.y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, jMinBox.z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, jMaxBox.x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, jMaxBox.y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, jMaxBox.z)
			}

			for j := i; j < len(triangles); j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				rightBBox[0].x = math32.Min(rightBBox[0].x, jMinBox.x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, jMinBox.y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, jMinBox.z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, jMaxBox.x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, jMaxBox.y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, jMaxBox.z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			return iMinBox.x < jMinBox.x
			// return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			return iMinBox.y < jMinBox.y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			return iMinBox.z < jMinBox.z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []TriangleSimple) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		minBox, maxBox := triangle.CalculateBoundingBox()
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, minBox.x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, minBox.y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, minBox.z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, maxBox.x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, maxBox.y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, maxBox.z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []TriangleSimple {
	triangles := []TriangleSimple{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = clampUint8(c.R)
					pixelBuffer[index+1] = clampUint8(c.G)
					pixelBuffer[index+2] = clampUint8(c.B)
					pixelBuffer[index+3] = clampUint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

func DrawSpheres(spheres []SphereSimple, camera Camera, scaling int, iterations int, subImages []*ebiten.Image, light Light) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c, _ := RayMarching(Ray{origin: camera.Position, direction: rayDir}, spheres, iterations, light)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 6, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor ColorFloat32, reflection float32, specular float32, directToScatter float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
		if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
			// fmt.Println(""Triangle hit"", triangle.color)
			NewTriangle := TriangleSimple{
				v1:              node.Triangles.v1,
				v2:              node.Triangles.v2,
				v3:              node.Triangles.v3,
				color:           newColor,
				Normal:          node.Triangles.Normal,
				reflection:      reflection,
				specular:        specular,
				directToScatter: directToScatter,
			}
			node.Triangles = NewTriangle
			return true
		}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {
		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, ColorFloat32{float32(g.r * 255), float32(g.g * 255), float32(g.b * 255), float32(g.a * 255)}, g.reflection, g.specular, g.directToScatter)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	if !Benchmark {
		DrawSpheres(g.Spheres, g.camera, g.scaleFactor, 32, g.subImages, g.light)
		for i, subImage := range g.subImages {
			op := &ebiten.DrawImageOptions{}
			// if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
			// } else {
			// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
			// }
			g.currentFrame.DrawImage(subImage, op)
		}
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
			if screenResolution.Selected == 0 {
				g.scaleFactor = 1
			}
			g.scaleFactor = screenResolution.Selected * 2
		}

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	Spheres         []SphereSimple
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

const subImageHeight = screenHeight / numCPU / 2
const subImageWidth = screenWidth

var fullScreen = false
var startTime time.Time

var Spheres = []SphereSimple{}

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 1.5}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		Spheres:       obj.ConvertToSquare(32),

		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",190.89,0.05,234.68,17.93
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color ColorFloat32
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = ColorFloat32{
				R: float32(r * 255),
				G: float32(g * 255),
				B: float32(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := TriangleSimple{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						// triangle.color = color.RGBA{255, 125, 0, 255} // Default color
						triangle.color = ColorFloat32{255, 125, 0, 255} // Default color
					}

					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

func (v Vector) Reflect(normal Vector) Vector {
	return v.Sub(normal.Mul(2 * v.Dot(normal)))
}

type Ray struct {
	origin, direction Vector
}

//	type Triangle struct {
//		v1, v2, v3  Vector
//		color       color.RGBA
//		BoundingBox [2]Vector
//		Normal      Vector
//		reflection  float32
//		specular    float32
//	}

type ColorFloat32 struct {
	R, G, B, A float32
}

type TriangleSimple struct {
	v1, v2, v3 Vector
	// color           color.RGBA
	color           ColorFloat32
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

type SphereSimple struct {
	center Vector
	radius float32
	color  color.RGBA
}

func Distance(v1, v2 Vector, radius float32) float32 {
	// Use vector subtraction and dot product instead of individual calculations
	diff := v1.Sub(v2)
	return diff.Length() - radius
}

// Add normal calculation for spheres
func calculateNormal(point, center Vector) Vector {
	return point.Sub(center).Normalize()
}

type RayMarchingBVH struct {
	BoundingBox [2]Vector
	Sphere      *SphereSimple
	Left, Right *RayMarchingBVH
	Active      bool
}

func calculateSphereSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func calculateSphereBoundingBox(sphere SphereSimple) [2]Vector {
	return [2]Vector{
		{
			x: sphere.center.x - sphere.radius,
			y: sphere.center.y - sphere.radius,
			z: sphere.center.z - sphere.radius,
		},
		{
			x: sphere.center.x + sphere.radius,
			y: sphere.center.y + sphere.radius,
			z: sphere.center.z + sphere.radius,
		},
	}
}

func BuildBvhForSpheres(spheres []SphereSimple, maxDepth int) *RayMarchingBVH {
	if len(spheres) == 0 {
		return nil
	}

	// Calculate the overall bounding box
	boundingBox := [2]Vector{
		{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
		{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
	}

	for _, sphere := range spheres {
		sphereBBox := calculateSphereBoundingBox(sphere)
		boundingBox[0].x = float32(math.Min(float64(boundingBox[0].x), float64(sphereBBox[0].x)))
		boundingBox[0].y = float32(math.Min(float64(boundingBox[0].y), float64(sphereBBox[0].y)))
		boundingBox[0].z = float32(math.Min(float64(boundingBox[0].z), float64(sphereBBox[0].z)))

		boundingBox[1].x = float32(math.Max(float64(boundingBox[1].x), float64(sphereBBox[1].x)))
		boundingBox[1].y = float32(math.Max(float64(boundingBox[1].y), float64(sphereBBox[1].y)))
		boundingBox[1].z = float32(math.Max(float64(boundingBox[1].z), float64(sphereBBox[1].z)))
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(spheres) <= 1 || maxDepth <= 0 {
		node := &RayMarchingBVH{
			BoundingBox: boundingBox,
			Sphere: &SphereSimple{
				center: spheres[0].center,
				radius: spheres[0].radius,
				color:  spheres[0].color,
			},
			Active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort spheres along the current axis
		switch axis {
		case 0:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.x < spheres[j].center.x
			})
		case 1:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.y < spheres[j].center.y
			})
		case 2:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.z < spheres[j].center.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(spheres); i++ {
			leftBBox := [2]Vector{
				{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
				{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
				{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
			}

			// Calculate left bounding box
			for j := 0; j < i; j++ {
				sphereBBox := calculateSphereBoundingBox(spheres[j])
				leftBBox[0].x = float32(math.Min(float64(leftBBox[0].x), float64(sphereBBox[0].x)))
				leftBBox[0].y = float32(math.Min(float64(leftBBox[0].y), float64(sphereBBox[0].y)))
				leftBBox[0].z = float32(math.Min(float64(leftBBox[0].z), float64(sphereBBox[0].z)))
				leftBBox[1].x = float32(math.Max(float64(leftBBox[1].x), float64(sphereBBox[1].x)))
				leftBBox[1].y = float32(math.Max(float64(leftBBox[1].y), float64(sphereBBox[1].y)))
				leftBBox[1].z = float32(math.Max(float64(leftBBox[1].z), float64(sphereBBox[1].z)))
			}

			// Calculate right bounding box
			for j := i; j < len(spheres); j++ {
				sphereBBox := calculateSphereBoundingBox(spheres[j])
				rightBBox[0].x = float32(math.Min(float64(rightBBox[0].x), float64(sphereBBox[0].x)))
				rightBBox[0].y = float32(math.Min(float64(rightBBox[0].y), float64(sphereBBox[0].y)))
				rightBBox[0].z = float32(math.Min(float64(rightBBox[0].z), float64(sphereBBox[0].z)))
				rightBBox[1].x = float32(math.Max(float64(rightBBox[1].x), float64(sphereBBox[1].x)))
				rightBBox[1].y = float32(math.Max(float64(rightBBox[1].y), float64(sphereBBox[1].y)))
				rightBBox[1].z = float32(math.Max(float64(rightBBox[1].z), float64(sphereBBox[1].z)))
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSphereSurfaceArea(leftBBox) + float32(len(spheres)-i)*calculateSphereSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort spheres along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.x < spheres[j].center.x
		})
	case 1:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.y < spheres[j].center.y
		})
	case 2:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.z < spheres[j].center.z
		})
	}

	// Create the BVH node with the best split
	node := &RayMarchingBVH{BoundingBox: boundingBox}
	node.Left = BuildBvhForSpheres(spheres[:bestSplit], maxDepth-1)
	node.Right = BuildBvhForSpheres(spheres[bestSplit:], maxDepth-1)

	return node
}

var sphereBVH = RayMarchingBVH{}

func IntersectBVH_RayMarching(bvh RayMarchingBVH, ray Ray) (bool, *SphereSimple) {
	if !BoundingBoxCollision(bvh.BoundingBox, &ray) {
		return false, nil
	}

	if bvh.Sphere != nil {
		return true, bvh.Sphere
	}

	hitLeft, left := IntersectBVH_RayMarching(*bvh.Left, ray)
	hitRight, right := IntersectBVH_RayMarching(*bvh.Right, ray)

	if hitLeft && hitRight {
		if Distance(ray.origin, left.center, left.radius) < Distance(ray.origin, right.center, right.radius) {
			return true, left
		}
		return true, right
	}

	if hitLeft {
		return true, left
	}

	if hitRight {
		return true, right
	}

	return false, nil
}

// Improved sphere conversion with pre-allocated slice
func (obj object) ConvertToSquare(count int) []SphereSimple {
	spheres := make([]SphereSimple, 0, count)

	for i := 0; i < count; i += 1 {
		randIndex := rand.Intn(len(obj.triangles))
		R := clampUint8(obj.triangles[randIndex].color.R)
		G := clampUint8(obj.triangles[randIndex].color.G)
		B := clampUint8(obj.triangles[randIndex].color.B)
		spheres = append(spheres, SphereSimple{
			center: obj.triangles[randIndex].v1,
			radius: 2,
			// color:  obj.triangles[randIndex].color,
			color: color.RGBA{R, G, B, 255},
		})
	}
	return spheres
}

func RayMarchBvh(ray Ray, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
	)

	var (
		totalDistance float32
		closestSphere *SphereSimple
		currentPoint  Vector
	)

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		hit, sphere := IntersectBVH_RayMarching(sphereBVH, ray)
		if hit {
			minDistance = Distance(currentPoint, sphere.center, sphere.radius)
			closestSphere = sphere
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, *closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, *closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

func RayMarching(ray Ray, spheres []SphereSimple, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
	)

	var (
		totalDistance float32
		sphereColor   = color.RGBA{0, 0, 0, 255}
		closestSphere SphereSimple
		currentPoint  Vector
	)

	// Early exit if no spheres
	if len(spheres) == 0 {
		return sphereColor, totalDistance
	}

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		// Find closest sphere
		for _, sphere := range spheres {
			if dist := Distance(currentPoint, sphere.center, sphere.radius); dist < minDistance {
				minDistance = dist
				closestSphere = sphere
			}
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

// Helper function for color shading calculations
func calculateShading(point Vector, sphere SphereSimple, totalDistance, maxDistance float32, light Light) color.RGBA {

	// Calculate normal at intersection point
	normal := calculateNormal(point, sphere.center)

	// Calculate light direction
	lightDir := light.Position.Sub(point).Normalize()

	// Ambient component
	ambientStrength := float32(0.1)
	ambient := float32(sphere.color.R) * ambientStrength

	// Diffuse component
	diff := max(normal.Dot(lightDir), 0.0)
	diffuse := diff * float32(sphere.color.R)

	// Specular component
	specularStrength := float32(0.5)
	viewDir := point.Mul(-1).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(normal)
	spec := math32.Pow(max(viewDir.Dot(reflectDir), 0.0), 32)
	specular := specularStrength * spec

	// Distance attenuation
	// attenuation := maxDistance / totalDistance

	// Combine components
	final := min((ambient + diffuse + specular), 255)

	return color.RGBA{
		R: uint8(final / 255 * float32(sphere.color.R)),
		G: uint8(final / 255 * float32(sphere.color.G)),
		B: uint8(final / 255 * float32(sphere.color.B)),
		A: 255,
	}
}

func (t *TriangleSimple) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *TriangleSimple) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color ColorFloat32, refection float32, specular float32) []TriangleSimple {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []TriangleSimple{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []TriangleSimple{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	var triangles []TriangleSimple
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

// func (triangle *Triangle) CalculateBoundingBox() {
// 	// Compute the minimum and maximum coordinates using float32 functions
// 	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
// 	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
// 	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
// 	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
// 	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
// 	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

// 	// Set the BoundingBox with computed min and max values
// 	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
// 	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
// }

func (triangle TriangleSimple) CalculateBoundingBox() (minBox Vector, maxBox Vector) {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	return Vector{minX, minY, minZ}, Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color ColorFloat32, reflection float32, specular float32) TriangleSimple {
	triangle := TriangleSimple{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular, directToScatter: 0.5}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

// func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
// 	// Precompute the inverse direction
// 	invDirX := 1.0 / ray.direction.x
// 	invDirY := 1.0 / ray.direction.y
// 	invDirZ := 1.0 / ray.direction.z

// 	// Compute the tmin and tmax for each axis directly
// 	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
// 	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
// 	tmin := min(tx1, tx2)
// 	tmax := max(tx1, tx2)

// 	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
// 	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
// 	tmin = max(tmin, min(ty1, ty2))
// 	tmax = min(tmax, max(ty1, ty2))

// 	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
// 	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
// 	tmin = max(tmin, min(tz1, tz2))
// 	tmax = min(tmax, max(tz1, tz2))

// 	// Final intersection check
// 	return tmax >= max(0.0, tmin)
// }

type Intersection struct {
	PointOfIntersection Vector
	Color               ColorFloat32
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

// func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
// 	// Check if the ray intersects the bounding box of the triangle first
// 	if !triangle.IntersectBoundingBox(*ray) {
// 		return Intersection{}, false
// 	}

// 	// Möller–Trumbore intersection algorithm
// 	edge1 := triangle.v2.Sub(triangle.v1)
// 	edge2 := triangle.v3.Sub(triangle.v1)
// 	h := ray.direction.Cross(edge2)
// 	a := edge1.Dot(h)
// 	if a > -0.00001 && a < 0.00001 {
// 		return Intersection{}, false
// 	}
// 	f := 1.0 / a
// 	s := ray.origin.Sub(triangle.v1)
// 	u := f * s.Dot(h)
// 	if u < 0.0 || u > 1.0 {
// 		return Intersection{}, false
// 	}
// 	q := s.Cross(edge1)
// 	v := f * ray.direction.Dot(q)
// 	if v < 0.0 || u+v > 1.0 {
// 		return Intersection{}, false
// 	}
// 	t := f * edge2.Dot(q)
// 	if t > 0.00001 {
// 		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
// 	}
// 	return Intersection{}, false
// }

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

// func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
// 	// Initialize the closest intersection and hit status
// 	closestIntersection := Intersection{Distance: math32.MaxFloat32}
// 	hasIntersection := false

// 	// Iterate over each triangle for the given ray
// 	for _, triangle := range triangles {
// 		// Check if the ray intersects the bounding box of the triangle first
// 		if !triangle.IntersectBoundingBox(ray) {
// 			continue
// 		}

// 		// Möller–Trumbore intersection algorithm
// 		edge1 := triangle.v2.Sub(triangle.v1)
// 		edge2 := triangle.v3.Sub(triangle.v1)
// 		h := ray.direction.Cross(edge2)
// 		a := edge1.Dot(h)
// 		if a > -0.00001 && a < 0.00001 {
// 			continue
// 		}
// 		f := 1.0 / a
// 		s := ray.origin.Sub(triangle.v1)
// 		u := f * s.Dot(h)
// 		if u < 0.0 || u > 1.0 {
// 			continue
// 		}
// 		q := s.Cross(edge1)
// 		v := f * ray.direction.Dot(q)
// 		if v < 0.0 || u+v > 1.0 {
// 			continue
// 		}
// 		t := f * edge2.Dot(q)
// 		if t > 0.00001 {
// 			tempIntersection := Intersection{
// 				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
// 				Color:               triangle.color,
// 				Normal:              triangle.Normal,
// 				Direction:           ray.direction,
// 				Distance:            t,
// 				reflection:          triangle.reflection,
// 				specular:            triangle.specular,
// 			}

// 			// Update the closest intersection if the new one is closer
// 			if t < closestIntersection.Distance {
// 				closestIntersection = tempIntersection
// 				hasIntersection = true
// 			}
// 		}
// 	}

// 	return closestIntersection, hasIntersection
// }

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) ColorFloat32 {
	if depth == 0 {
		return ColorFloat32{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return ColorFloat32{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorFloat32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(intersection.Normal)

	reflectRayOrigin := intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001))

	reflectRay := Ray{origin: reflectRayOrigin, direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorFloat32{
		R: tempIntersection.Color.R * intersection.reflection,
		G: tempIntersection.Color.G * intersection.reflection,
		B: tempIntersection.Color.B * intersection.reflection,
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    reflectRayOrigin,
		direction: lightDir,
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity = float32(0.005)
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	}

	finalColor := ColorFloat32{
		R: ((directReflectionColor.R + scatteredColor.R) * (1 - intersection.directToScatter)) + ((intersection.Color.R) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		G: ((directReflectionColor.G + scatteredColor.G) * (1 - intersection.directToScatter)) + ((intersection.Color.G) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		B: ((directReflectionColor.B + scatteredColor.B) * (1 - intersection.directToScatter)) + ((intersection.Color.B) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: reflectRayOrigin, direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := ColorFloat32{
		R: (finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter))),
		G: (finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter))),
		B: (finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter))),
		A: finalColor.A,
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []TriangleSimple
	BoundingBox [2]Vector
}

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	Triangles := []TriangleSimple{}
	for _, object := range objects {
		Triangles = append(Triangles, object.triangles...)
	}
	return buildBVHNode(Triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active      bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []TriangleSimple, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		minBox, maxBox := triangle.CalculateBoundingBox()
		boundingBox[0].x = math32.Min(boundingBox[0].x, minBox.x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, minBox.y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, minBox.z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, maxBox.x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, maxBox.y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, maxBox.z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles: TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: ColorFloat32{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.x < jMinBox.x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.y < jMinBox.y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.z < jMinBox.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				leftBBox[0].x = math32.Min(leftBBox[0].x, jMinBox.x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, jMinBox.y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, jMinBox.z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, jMaxBox.x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, jMaxBox.y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, jMaxBox.z)
			}

			for j := i; j < len(triangles); j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				rightBBox[0].x = math32.Min(rightBBox[0].x, jMinBox.x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, jMinBox.y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, jMinBox.z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, jMaxBox.x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, jMaxBox.y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, jMaxBox.z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			return iMinBox.x < jMinBox.x
			// return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			return iMinBox.y < jMinBox.y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			return iMinBox.z < jMinBox.z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []TriangleSimple) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		minBox, maxBox := triangle.CalculateBoundingBox()
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, minBox.x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, minBox.y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, minBox.z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, maxBox.x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, maxBox.y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, maxBox.z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []TriangleSimple {
	triangles := []TriangleSimple{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = clampUint8(c.R)
					pixelBuffer[index+1] = clampUint8(c.G)
					pixelBuffer[index+2] = clampUint8(c.B)
					pixelBuffer[index+3] = clampUint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

func DrawSpheres(spheres []SphereSimple, camera Camera, scaling int, iterations int, subImages []*ebiten.Image, light Light) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					// c, _ := RayMarching(Ray{origin: camera.Position, direction: rayDir}, spheres, iterations, light)
					c, _ := RayMarchBvh(Ray{origin: camera.Position, direction: rayDir}, iterations, light)
					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32, m *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Light Intensity"", m, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 6, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 7, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor ColorFloat32, reflection float32, specular float32, directToScatter float32, multiplayer float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
		if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
			// fmt.Println(""Triangle hit"", triangle.color)
			m := float32(1)
			if multiplayer > 0.05 {
				m = (multiplayer + 1)
			}

			c := ColorFloat32{
				R: newColor.R * (m * m * m),
				G: newColor.G * (m * m * m),
				B: newColor.B * (m * m * m),
				A: newColor.A,
			}
			NewTriangle := TriangleSimple{
				v1:              node.Triangles.v1,
				v2:              node.Triangles.v2,
				v3:              node.Triangles.v3,
				color:           c,
				Normal:          node.Triangles.Normal,
				reflection:      reflection,
				specular:        specular,
				directToScatter: directToScatter,
			}
			node.Triangles = NewTriangle
			return true
		}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter, multiplayer)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter, multiplayer)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {

		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, ColorFloat32{float32(g.r * 255), float32(g.g * 255), float32(g.b * 255), float32(g.a * 255)}, g.reflection, g.specular, g.directToScatter, g.ColorMultiplier)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}

	rayMarching = Options{
		Header:    ""Ray Marching"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 500,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	/// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	if !Benchmark && rayMarching.Selected == 1 {
		DrawSpheres(g.Spheres, g.camera, g.scaleFactor, 32, g.subImages, g.light)
		for i, subImage := range g.subImages {
			op := &ebiten.DrawImageOptions{}
			// if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
			// } else {
			// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
			// }
			g.currentFrame.DrawImage(subImage, op)
		}
	}


	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
				GUI.Clear()
				ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter, &g.ColorMultiplier)
				SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&rayMarching, GUI, mouseX, mouseY, mousePressed)
				guiNeedsUpdate = false
				if screenResolution.Selected == 0 {
					g.scaleFactor = 1
				}
				g.scaleFactor = screenResolution.Selected * 2
		}
		lastMousePressed = mousePressed

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// rayMarchingOpts := &ebiten.DrawRectShaderOptions{}
	// rayMarchingOpts.Images[0] = g.currentFrame
	// rayMarchingOpts.Uniforms = map[string]interface{}{
	// 	""StartPosition"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""TopLeft"":     []float32{ScreenSpaceCoordinates[0][0].x, ScreenSpaceCoordinates[0][0].y, ScreenSpaceCoordinates[0][0].z},
	// 	""TopRight"":   []float32{ScreenSpaceCoordinates[screenWidth-1][0].x, ScreenSpaceCoordinates[screenWidth-1][0].y, ScreenSpaceCoordinates[screenWidth-1][0].z},
	// 	""BottomLeft"":  []float32{ScreenSpaceCoordinates[0][screenHeight-1].x, ScreenSpaceCoordinates[0][screenHeight-1].y, ScreenSpaceCoordinates[0][screenHeight-1].z},
	// }

	// // Apply the ray marching shader
	// rayMarchingImage.DrawRectShader(
	// 	rayMarchingImage.Bounds().Dx(),
	// 	rayMarchingImage.Bounds().Dy(),
	// 	g.RayMarchShader,
	// 	rayMarchingOpts,
	// )

	// // Draw the ray marching image to the screen
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(rayMarchingImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(rayMarchingImage.Bounds().Dy()))
	// screen.DrawImage(rayMarchingImage, op1)

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	Spheres         []SphereSimple
	ColorMultiplier float32
	RayMarchShader  *ebiten.Shader
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

const subImageHeight = screenHeight / numCPU / 2
const subImageWidth = screenWidth

var fullScreen = false
var startTime time.Time

var Spheres = []SphereSimple{}

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	src, err = LoadShader(""shaders/rayMarching.kage"")
	if err != nil {
		panic(err)
	}

	rayMarchingShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", rayMarchingShader)

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{2, 0, 4}, intensity: 0.25}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	s := obj.ConvertToSquare(256)
	sphereBVH = *BuildBvhForSpheres(s, 6)

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:   ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		Spheres:        s,
		RayMarchShader: rayMarchingShader,
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",193.49,0.05,237.12,15.53
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 16

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color ColorFloat32
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = ColorFloat32{
				R: float32(r * 255),
				G: float32(g * 255),
				B: float32(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := TriangleSimple{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						// triangle.color = color.RGBA{255, 125, 0, 255} // Default color
						triangle.color = ColorFloat32{255, 125, 0, 255} // Default color
					}

					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

func (v Vector) Reflect(normal Vector) Vector {
	return v.Sub(normal.Mul(2 * v.Dot(normal)))
}

type Ray struct {
	origin, direction Vector
}

//	type Triangle struct {
//		v1, v2, v3  Vector
//		color       color.RGBA
//		BoundingBox [2]Vector
//		Normal      Vector
//		reflection  float32
//		specular    float32
//	}

type ColorFloat32 struct {
	R, G, B, A float32
}

type TriangleSimple struct {
	v1, v2, v3 Vector
	// color           color.RGBA
	color           ColorFloat32
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

type SphereSimple struct {
	center Vector
	radius float32
	color  color.RGBA
}

func Distance(v1, v2 Vector, radius float32) float32 {
	// Use vector subtraction and dot product instead of individual calculations
	diff := v1.Sub(v2)
	return diff.Length() - radius
}

// Add normal calculation for spheres
func calculateNormal(point, center Vector) Vector {
	return point.Sub(center).Normalize()
}

type RayMarchingBVH struct {
	BoundingBox [2]Vector
	Sphere      *SphereSimple
	Left, Right *RayMarchingBVH
	Active      bool
}

func calculateSphereSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func calculateSphereBoundingBox(sphere SphereSimple) [2]Vector {
	return [2]Vector{
		{
			x: sphere.center.x - sphere.radius,
			y: sphere.center.y - sphere.radius,
			z: sphere.center.z - sphere.radius,
		},
		{
			x: sphere.center.x + sphere.radius,
			y: sphere.center.y + sphere.radius,
			z: sphere.center.z + sphere.radius,
		},
	}
}

func BuildBvhForSpheres(spheres []SphereSimple, maxDepth int) *RayMarchingBVH {
	if len(spheres) == 0 {
		return nil
	}

	// Calculate the overall bounding box
	boundingBox := [2]Vector{
		{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
		{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
	}

	for _, sphere := range spheres {
		sphereBBox := calculateSphereBoundingBox(sphere)
		boundingBox[0].x = float32(math.Min(float64(boundingBox[0].x), float64(sphereBBox[0].x)))
		boundingBox[0].y = float32(math.Min(float64(boundingBox[0].y), float64(sphereBBox[0].y)))
		boundingBox[0].z = float32(math.Min(float64(boundingBox[0].z), float64(sphereBBox[0].z)))

		boundingBox[1].x = float32(math.Max(float64(boundingBox[1].x), float64(sphereBBox[1].x)))
		boundingBox[1].y = float32(math.Max(float64(boundingBox[1].y), float64(sphereBBox[1].y)))
		boundingBox[1].z = float32(math.Max(float64(boundingBox[1].z), float64(sphereBBox[1].z)))
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(spheres) <= 1 || maxDepth <= 0 {
		node := &RayMarchingBVH{
			BoundingBox: boundingBox,
			Sphere: &SphereSimple{
				center: spheres[0].center,
				radius: spheres[0].radius,
				color:  spheres[0].color,
			},
			Active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort spheres along the current axis
		switch axis {
		case 0:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.x < spheres[j].center.x
			})
		case 1:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.y < spheres[j].center.y
			})
		case 2:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.z < spheres[j].center.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(spheres); i++ {
			leftBBox := [2]Vector{
				{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
				{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
				{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
			}

			// Calculate left bounding box
			for j := 0; j < i; j++ {
				sphereBBox := calculateSphereBoundingBox(spheres[j])
				leftBBox[0].x = float32(math.Min(float64(leftBBox[0].x), float64(sphereBBox[0].x)))
				leftBBox[0].y = float32(math.Min(float64(leftBBox[0].y), float64(sphereBBox[0].y)))
				leftBBox[0].z = float32(math.Min(float64(leftBBox[0].z), float64(sphereBBox[0].z)))
				leftBBox[1].x = float32(math.Max(float64(leftBBox[1].x), float64(sphereBBox[1].x)))
				leftBBox[1].y = float32(math.Max(float64(leftBBox[1].y), float64(sphereBBox[1].y)))
				leftBBox[1].z = float32(math.Max(float64(leftBBox[1].z), float64(sphereBBox[1].z)))
			}

			// Calculate right bounding box
			for j := i; j < len(spheres); j++ {
				sphereBBox := calculateSphereBoundingBox(spheres[j])
				rightBBox[0].x = float32(math.Min(float64(rightBBox[0].x), float64(sphereBBox[0].x)))
				rightBBox[0].y = float32(math.Min(float64(rightBBox[0].y), float64(sphereBBox[0].y)))
				rightBBox[0].z = float32(math.Min(float64(rightBBox[0].z), float64(sphereBBox[0].z)))
				rightBBox[1].x = float32(math.Max(float64(rightBBox[1].x), float64(sphereBBox[1].x)))
				rightBBox[1].y = float32(math.Max(float64(rightBBox[1].y), float64(sphereBBox[1].y)))
				rightBBox[1].z = float32(math.Max(float64(rightBBox[1].z), float64(sphereBBox[1].z)))
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSphereSurfaceArea(leftBBox) + float32(len(spheres)-i)*calculateSphereSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort spheres along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.x < spheres[j].center.x
		})
	case 1:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.y < spheres[j].center.y
		})
	case 2:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.z < spheres[j].center.z
		})
	}

	// Create the BVH node with the best split
	node := &RayMarchingBVH{BoundingBox: boundingBox}
	node.Left = BuildBvhForSpheres(spheres[:bestSplit], maxDepth-1)
	node.Right = BuildBvhForSpheres(spheres[bestSplit:], maxDepth-1)

	return node
}

var sphereBVH = RayMarchingBVH{}

func IntersectBVH_RayMarching(bvh RayMarchingBVH, ray Ray) (bool, *SphereSimple) {
	if !BoundingBoxCollision(bvh.BoundingBox, &ray) {
		return false, nil
	}

	if bvh.Sphere != nil {
		return true, bvh.Sphere
	}

	hitLeft, left := IntersectBVH_RayMarching(*bvh.Left, ray)
	hitRight, right := IntersectBVH_RayMarching(*bvh.Right, ray)

	if hitLeft && hitRight {
		if Distance(ray.origin, left.center, left.radius) < Distance(ray.origin, right.center, right.radius) {
			return true, left
		}
		return true, right
	}

	if hitLeft {
		return true, left
	}

	if hitRight {
		return true, right
	}

	return false, nil
}

// Improved sphere conversion with pre-allocated slice
func (obj object) ConvertToSquare(count int) []SphereSimple {
	spheres := make([]SphereSimple, 0, count)

	for i := 0; i < count; i += 1 {
		randIndex := rand.Intn(len(obj.triangles))
		R := clampUint8(obj.triangles[randIndex].color.R)
		G := clampUint8(obj.triangles[randIndex].color.G)
		B := clampUint8(obj.triangles[randIndex].color.B)
		spheres = append(spheres, SphereSimple{
			center: obj.triangles[randIndex].v1,
			radius: 2,
			// color:  obj.triangles[randIndex].color,
			color: color.RGBA{R, G, B, 255},
		})
	}
	return spheres
}

func RayMarchBvh(ray Ray, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
	)

	var (
		totalDistance float32
		closestSphere *SphereSimple
		currentPoint  Vector
	)

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		hit, sphere := IntersectBVH_RayMarching(sphereBVH, ray)
		if hit {
			minDistance = Distance(currentPoint, sphere.center, sphere.radius)
			closestSphere = sphere
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, *closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, *closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

func RayMarching(ray Ray, spheres []SphereSimple, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
	)

	var (
		totalDistance float32
		sphereColor   = color.RGBA{0, 0, 0, 255}
		closestSphere SphereSimple
		currentPoint  Vector
	)

	// Early exit if no spheres
	if len(spheres) == 0 {
		return sphereColor, totalDistance
	}

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		// Find closest sphere
		for _, sphere := range spheres {
			if dist := Distance(currentPoint, sphere.center, sphere.radius); dist < minDistance {
				minDistance = dist
				closestSphere = sphere
			}
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

// Helper function for color shading calculations
func calculateShading(point Vector, sphere SphereSimple, totalDistance, maxDistance float32, light Light) color.RGBA {

	// Calculate normal at intersection point
	normal := calculateNormal(point, sphere.center)

	// Calculate light direction
	lightDir := light.Position.Sub(point).Normalize()

	// Ambient component
	ambientStrength := float32(0.1)
	ambient := float32(sphere.color.R) * ambientStrength

	// Diffuse component
	diff := max(normal.Dot(lightDir), 0.0)
	diffuse := diff * float32(sphere.color.R)

	// Specular component
	specularStrength := float32(0.5)
	viewDir := point.Mul(-1).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(normal)
	spec := math32.Pow(max(viewDir.Dot(reflectDir), 0.0), 32)
	specular := specularStrength * spec

	// Distance attenuation
	// attenuation := maxDistance / totalDistance

	// Combine components
	final := min((ambient + diffuse + specular), 255)

	return color.RGBA{
		R: uint8(final / 255 * float32(sphere.color.R)),
		G: uint8(final / 255 * float32(sphere.color.G)),
		B: uint8(final / 255 * float32(sphere.color.B)),
		A: 255,
	}
}

func (t *TriangleSimple) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *TriangleSimple) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color ColorFloat32, refection float32, specular float32) []TriangleSimple {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []TriangleSimple{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []TriangleSimple{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	var triangles []TriangleSimple
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

// func (triangle *Triangle) CalculateBoundingBox() {
// 	// Compute the minimum and maximum coordinates using float32 functions
// 	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
// 	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
// 	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
// 	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
// 	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
// 	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

// 	// Set the BoundingBox with computed min and max values
// 	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
// 	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
// }

func (triangle TriangleSimple) CalculateBoundingBox() (minBox Vector, maxBox Vector) {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	return Vector{minX, minY, minZ}, Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color ColorFloat32, reflection float32, specular float32) TriangleSimple {
	triangle := TriangleSimple{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular, directToScatter: 0.5}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

// func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
// 	// Precompute the inverse direction
// 	invDirX := 1.0 / ray.direction.x
// 	invDirY := 1.0 / ray.direction.y
// 	invDirZ := 1.0 / ray.direction.z

// 	// Compute the tmin and tmax for each axis directly
// 	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
// 	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
// 	tmin := min(tx1, tx2)
// 	tmax := max(tx1, tx2)

// 	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
// 	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
// 	tmin = max(tmin, min(ty1, ty2))
// 	tmax = min(tmax, max(ty1, ty2))

// 	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
// 	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
// 	tmin = max(tmin, min(tz1, tz2))
// 	tmax = min(tmax, max(tz1, tz2))

// 	// Final intersection check
// 	return tmax >= max(0.0, tmin)
// }

type Intersection struct {
	PointOfIntersection Vector
	Color               ColorFloat32
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

// func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
// 	// Check if the ray intersects the bounding box of the triangle first
// 	if !triangle.IntersectBoundingBox(*ray) {
// 		return Intersection{}, false
// 	}

// 	// Möller–Trumbore intersection algorithm
// 	edge1 := triangle.v2.Sub(triangle.v1)
// 	edge2 := triangle.v3.Sub(triangle.v1)
// 	h := ray.direction.Cross(edge2)
// 	a := edge1.Dot(h)
// 	if a > -0.00001 && a < 0.00001 {
// 		return Intersection{}, false
// 	}
// 	f := 1.0 / a
// 	s := ray.origin.Sub(triangle.v1)
// 	u := f * s.Dot(h)
// 	if u < 0.0 || u > 1.0 {
// 		return Intersection{}, false
// 	}
// 	q := s.Cross(edge1)
// 	v := f * ray.direction.Dot(q)
// 	if v < 0.0 || u+v > 1.0 {
// 		return Intersection{}, false
// 	}
// 	t := f * edge2.Dot(q)
// 	if t > 0.00001 {
// 		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
// 	}
// 	return Intersection{}, false
// }

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

// func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
// 	// Initialize the closest intersection and hit status
// 	closestIntersection := Intersection{Distance: math32.MaxFloat32}
// 	hasIntersection := false

// 	// Iterate over each triangle for the given ray
// 	for _, triangle := range triangles {
// 		// Check if the ray intersects the bounding box of the triangle first
// 		if !triangle.IntersectBoundingBox(ray) {
// 			continue
// 		}

// 		// Möller–Trumbore intersection algorithm
// 		edge1 := triangle.v2.Sub(triangle.v1)
// 		edge2 := triangle.v3.Sub(triangle.v1)
// 		h := ray.direction.Cross(edge2)
// 		a := edge1.Dot(h)
// 		if a > -0.00001 && a < 0.00001 {
// 			continue
// 		}
// 		f := 1.0 / a
// 		s := ray.origin.Sub(triangle.v1)
// 		u := f * s.Dot(h)
// 		if u < 0.0 || u > 1.0 {
// 			continue
// 		}
// 		q := s.Cross(edge1)
// 		v := f * ray.direction.Dot(q)
// 		if v < 0.0 || u+v > 1.0 {
// 			continue
// 		}
// 		t := f * edge2.Dot(q)
// 		if t > 0.00001 {
// 			tempIntersection := Intersection{
// 				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
// 				Color:               triangle.color,
// 				Normal:              triangle.Normal,
// 				Direction:           ray.direction,
// 				Distance:            t,
// 				reflection:          triangle.reflection,
// 				specular:            triangle.specular,
// 			}

// 			// Update the closest intersection if the new one is closer
// 			if t < closestIntersection.Distance {
// 				closestIntersection = tempIntersection
// 				hasIntersection = true
// 			}
// 		}
// 	}

// 	return closestIntersection, hasIntersection
// }

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) ColorFloat32 {
	if depth == 0 {
		return ColorFloat32{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return ColorFloat32{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorFloat32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(intersection.Normal)

	reflectRayOrigin := intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001))

	reflectRay := Ray{origin: reflectRayOrigin, direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorFloat32{
		R: tempIntersection.Color.R * intersection.reflection,
		G: tempIntersection.Color.G * intersection.reflection,
		B: tempIntersection.Color.B * intersection.reflection,
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    reflectRayOrigin,
		direction: lightDir,
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity = float32(0.005)
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	}

	finalColor := ColorFloat32{
		R: ((directReflectionColor.R + scatteredColor.R) * (1 - intersection.directToScatter)) + ((intersection.Color.R) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		G: ((directReflectionColor.G + scatteredColor.G) * (1 - intersection.directToScatter)) + ((intersection.Color.G) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		B: ((directReflectionColor.B + scatteredColor.B) * (1 - intersection.directToScatter)) + ((intersection.Color.B) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: reflectRayOrigin, direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := ColorFloat32{
		R: (finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter))),
		G: (finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter))),
		B: (finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter))),
		A: finalColor.A,
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []TriangleSimple
	BoundingBox [2]Vector
}

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	Triangles := []TriangleSimple{}
	for _, object := range objects {
		Triangles = append(Triangles, object.triangles...)
	}
	return buildBVHNode(Triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active      bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []TriangleSimple, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		minBox, maxBox := triangle.CalculateBoundingBox()
		boundingBox[0].x = math32.Min(boundingBox[0].x, minBox.x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, minBox.y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, minBox.z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, maxBox.x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, maxBox.y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, maxBox.z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles: TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: ColorFloat32{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.x < jMinBox.x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.y < jMinBox.y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.z < jMinBox.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				leftBBox[0].x = math32.Min(leftBBox[0].x, jMinBox.x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, jMinBox.y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, jMinBox.z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, jMaxBox.x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, jMaxBox.y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, jMaxBox.z)
			}

			for j := i; j < len(triangles); j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				rightBBox[0].x = math32.Min(rightBBox[0].x, jMinBox.x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, jMinBox.y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, jMinBox.z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, jMaxBox.x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, jMaxBox.y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, jMaxBox.z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			return iMinBox.x < jMinBox.x
			// return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			return iMinBox.y < jMinBox.y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			return iMinBox.z < jMinBox.z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []TriangleSimple) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		minBox, maxBox := triangle.CalculateBoundingBox()
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, minBox.x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, minBox.y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, minBox.z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, maxBox.x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, maxBox.y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, maxBox.z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []TriangleSimple {
	triangles := []TriangleSimple{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = clampUint8(c.R)
					pixelBuffer[index+1] = clampUint8(c.G)
					pixelBuffer[index+2] = clampUint8(c.B)
					pixelBuffer[index+3] = clampUint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

func DrawSpheres(camera Camera, scaling int, iterations int, subImages []*ebiten.Image, light Light) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					// c, _ := RayMarching(Ray{origin: camera.Position, direction: rayDir}, spheres, iterations, light)
					c, _ := RayMarchBvh(Ray{origin: camera.Position, direction: rayDir}, iterations, light)
					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}

func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32, m *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Light Intensity"", m, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 6, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 7, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor ColorFloat32, reflection float32, specular float32, directToScatter float32, multiplayer float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
		if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
			// fmt.Println(""Triangle hit"", triangle.color)
			m := float32(1)
			if multiplayer > 0.05 {
				m = (multiplayer + 1)
			}

			c := ColorFloat32{
				R: newColor.R * (m * m * m),
				G: newColor.G * (m * m * m),
				B: newColor.B * (m * m * m),
				A: newColor.A,
			}
			NewTriangle := TriangleSimple{
				v1:              node.Triangles.v1,
				v2:              node.Triangles.v2,
				v3:              node.Triangles.v3,
				color:           c,
				Normal:          node.Triangles.Normal,
				reflection:      reflection,
				specular:        specular,
				directToScatter: directToScatter,
			}
			node.Triangles = NewTriangle
			return true
		}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter, multiplayer)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter, multiplayer)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {

		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, ColorFloat32{float32(g.r * 255), float32(g.g * 255), float32(g.b * 255), float32(g.a * 255)}, g.reflection, g.specular, g.directToScatter, g.ColorMultiplier)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}

	rayMarching = Options{
		Header:    ""Ray Marching"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 500,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	/// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	if !Benchmark && rayMarching.Selected == 1 {
		DrawSpheres(g.camera, g.scaleFactor, 32, g.subImages, g.light)
		for i, subImage := range g.subImages {
			op := &ebiten.DrawImageOptions{}
			// if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
			// } else {
			// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
			// }
			g.currentFrame.DrawImage(subImage, op)
		}
	}


	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
				GUI.Clear()
				ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter, &g.ColorMultiplier)
				SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
				SelectOption(&rayMarching, GUI, mouseX, mouseY, mousePressed)
				guiNeedsUpdate = false
				if screenResolution.Selected == 0 {
					g.scaleFactor = 1
				}
				g.scaleFactor = screenResolution.Selected * 2
		}
		lastMousePressed = mousePressed

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// rayMarchingOpts := &ebiten.DrawRectShaderOptions{}
	// rayMarchingOpts.Images[0] = g.currentFrame
	// rayMarchingOpts.Uniforms = map[string]interface{}{
	// 	""StartPosition"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""TopLeft"":     []float32{ScreenSpaceCoordinates[0][0].x, ScreenSpaceCoordinates[0][0].y, ScreenSpaceCoordinates[0][0].z},
	// 	""TopRight"":   []float32{ScreenSpaceCoordinates[screenWidth-1][0].x, ScreenSpaceCoordinates[screenWidth-1][0].y, ScreenSpaceCoordinates[screenWidth-1][0].z},
	// 	""BottomLeft"":  []float32{ScreenSpaceCoordinates[0][screenHeight-1].x, ScreenSpaceCoordinates[0][screenHeight-1].y, ScreenSpaceCoordinates[0][screenHeight-1].z},
	// }

	// // Apply the ray marching shader
	// rayMarchingImage.DrawRectShader(
	// 	rayMarchingImage.Bounds().Dx(),
	// 	rayMarchingImage.Bounds().Dy(),
	// 	g.RayMarchShader,
	// 	rayMarchingOpts,
	// )

	// // Draw the ray marching image to the screen
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(rayMarchingImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(rayMarchingImage.Bounds().Dy()))
	// screen.DrawImage(rayMarchingImage, op1)

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	ColorMultiplier float32
	// RayMarchShader  *ebiten.Shader
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

const subImageHeight = screenHeight / numCPU / 2
const subImageWidth = screenWidth

var fullScreen = false
var startTime time.Time

var Spheres = []SphereSimple{}

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	src, err = LoadShader(""shaders/rayMarching.kage"")
	if err != nil {
		panic(err)
	}

	rayMarchingShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", rayMarchingShader)

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 2}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	sphereBVH = *BuildBvhForSpheres(obj.ConvertToSquare(256), 6)

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:   ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// RayMarchShader: rayMarchingShader,
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",192.79,0.05,237.80,10.84
"// TODO [High]: Use Vector 32

// FIXME[High]: UI elements merge into one layer and then draw on the screen
// : Implement the blur function [DONE]
// TODO [High]: Implement the increase contrast function
// TODO [High]: Implement the increase brightness function
// TODO [High]: Implement the decrease brightness function
// [High]: Implement the edge detection function [DONE]
// TODO [High]: Implement the decrease contrast function
// TODO [High]: Implement the sharpen function
// TODO [High]: Implement the eraser tool
// TODO [High]: Implement the fill tool
// TODO [High]: Implement the line tool
// TODO [High]: Implement Projection rendering

// TODO: Merge the changes from the previous commit
// TODO: Implement the Projection Rendering

package main

import (
	""bufio""
	""encoding/csv""
	""fmt""
	""image""
	""image/color""
	""io/ioutil""
	""math""
	""math/rand""
	""os""
	""runtime""
	""sort""
	""strconv""
	""strings""
	""sync""
	""time""

	""image/draw""

	""github.com/chewxy/math32""

	""github.com/hajimehoshi/ebiten/v2""
	""github.com/hajimehoshi/ebiten/v2/ebitenutil""
)

const screenWidth = 800
const screenHeight = 608
const rowSize = screenHeight / numCPU
const FOV = 45

var ScreenSpaceCoordinates [screenWidth][screenHeight]Vector

const maxDepth = 16
const numCPU = 30

const Benchmark = true

var AverageFrameRate float64 = 0.0
var MinFrameRate float64 = math.MaxFloat64
var MaxFrameRate float64 = 0.0
var FPS []float64

type Material struct {
	name  string
	color ColorFloat32
}

func LoadMTL(filename string) (map[string]Material, error) {
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var currentMaterial string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""newmtl"":
			if len(fields) < 2 {
				continue // Skip malformed material names
			}
			currentMaterial = fields[1]
			materials[currentMaterial] = Material{name: currentMaterial}

		case ""Kd"": // Diffuse color
			if len(fields) < 4 || currentMaterial == """" {
				continue // Skip if no material is currently being defined
			}
			r, err1 := strconv.ParseFloat(fields[1], 32)
			g, err2 := strconv.ParseFloat(fields[2], 32)
			b, err3 := strconv.ParseFloat(fields[3], 32)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed color definitions
			}
			mat := materials[currentMaterial]
			mat.color = ColorFloat32{
				R: float32(r * 255),
				G: float32(g * 255),
				B: float32(b * 255),
				A: 255,
			}
			materials[currentMaterial] = mat
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return materials, nil
}

func LoadOBJ(filename string) (object, error) {
	var obj object
	materials := make(map[string]Material)

	file, err := os.Open(filename)
	if err != nil {
		return obj, err
	}
	defer file.Close()

	var vertices []Vector
	var currentMaterial string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) == 0 || strings.HasPrefix(line, ""#"") {
			continue // Skip empty lines and comments
		}

		switch fields[0] {
		case ""v"":
			if len(fields) < 4 {
				continue // Ensure there are enough fields for vertex coordinates
			}
			x, err1 := strconv.ParseFloat(fields[1], 64)
			y, err2 := strconv.ParseFloat(fields[2], 64)
			z, err3 := strconv.ParseFloat(fields[3], 64)
			if err1 != nil || err2 != nil || err3 != nil {
				continue // Skip malformed vertex lines
			}
			vertices = append(vertices, Vector{float32(x), float32(y), float32(z)})

		case ""usemtl"":
			if len(fields) < 2 {
				continue // Skip malformed usemtl lines
			}
			currentMaterial = fields[1]

		case ""mtllib"":
			if len(fields) < 2 {
				continue // Skip malformed mtllib lines
			}
			mtlFilename := fields[1]
			loadedMaterials, err := LoadMTL(mtlFilename)
			if err != nil {
				return obj, err
			}
			// Merge the loaded materials into the materials map
			for name, mat := range loadedMaterials {
				materials[name] = mat
			}

		case ""f"":
			if len(fields) < 4 {
				continue // Skip lines without enough vertices
			}

			var indices []int
			for i := 1; i < len(fields); i++ {
				parts := strings.Split(fields[i], ""/"")
				if len(parts) == 0 {
					continue // Skip malformed face definitions
				}
				index, err := strconv.ParseInt(parts[0], 10, 64)
				if err != nil {
					continue // Skip malformed face definitions
				}
				if index < 0 {
					index = int64(len(vertices)) + index + 1
				}
				if index <= 0 || index > int64(len(vertices)) {
					continue // Skip invalid indices
				}
				indices = append(indices, int(index)-1)
			}

			if len(indices) >= 3 {
				for i := 1; i < len(indices)-1; i++ {
					triangle := TriangleSimple{
						v1:         vertices[indices[0]],
						v2:         vertices[indices[i]],
						v3:         vertices[indices[i+1]],
						reflection: 0.09,
						specular:   0.5,
					}

					// Apply the current material color if available
					if mat, exists := materials[currentMaterial]; exists {
						triangle.color = mat.color
						triangle.color.A = 255 // Ensure alpha is fully opaque
					} else {
						// triangle.color = color.RGBA{255, 125, 0, 255} // Default color
						triangle.color = ColorFloat32{255, 125, 0, 255} // Default color
					}

					obj.triangles = append(obj.triangles, triangle)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return obj, err
	}

	obj.CalculateBoundingBox()
	obj.CalculateNormals()

	return obj, nil
}

type Vector struct {
	x, y, z float32
}

func (v Vector) Length() float32 {
	return math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

func (v Vector) Add(v2 Vector) Vector {
	return Vector{v.x + v2.x, v.y + v2.y, v.z + v2.z}
}

func (v Vector) Sub(v2 Vector) Vector {
	return Vector{v.x - v2.x, v.y - v2.y, v.z - v2.z}
}

func (v Vector) Mul(scalar float32) Vector {
	return Vector{v.x * scalar, v.y * scalar, v.z * scalar}
}

func (v Vector) Dot(v2 Vector) float32 {
	return v.x*v2.x + v.y*v2.y + v.z*v2.z
}

func (v Vector) Cross(v2 Vector) Vector {
	return Vector{v.y*v2.z - v.z*v2.y, v.z*v2.x - v.x*v2.z, v.x*v2.y - v.y*v2.x}
}

func (v Vector) Normalize() Vector {
	magnitude := math32.Sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
	if magnitude == 0 {
		return Vector{0, 0, 0}
	}
	return Vector{v.x / magnitude, v.y / magnitude, v.z / magnitude}
}

func (v Vector) RotateX(angle float32) Vector {
	return Vector{
		x: v.x,
		y: v.y*math32.Cos(angle) - v.z*math32.Sin(angle),
		z: v.y*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateY(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) + v.z*math32.Sin(angle),
		y: v.y,
		z: -v.x*math32.Sin(angle) + v.z*math32.Cos(angle),
	}
}

func (v Vector) RotateZ(angle float32) Vector {
	return Vector{
		x: v.x*math32.Cos(angle) - v.y*math32.Sin(angle),
		y: v.x*math32.Sin(angle) + v.y*math32.Cos(angle),
		z: v.z,
	}
}

func (v Vector) Rotate(angleX, angleY, angleZ float32) Vector {
	return v.RotateX(angleX).RotateY(angleY).RotateZ(angleZ)
}

func (v Vector) Reflect(normal Vector) Vector {
	return v.Sub(normal.Mul(2 * v.Dot(normal)))
}

type Ray struct {
	origin, direction Vector
}

//	type Triangle struct {
//		v1, v2, v3  Vector
//		color       color.RGBA
//		BoundingBox [2]Vector
//		Normal      Vector
//		reflection  float32
//		specular    float32
//	}

type ColorFloat32 struct {
	R, G, B, A float32
}

type TriangleSimple struct {
	v1, v2, v3 Vector
	// color           color.RGBA
	color           ColorFloat32
	Normal          Vector
	reflection      float32
	directToScatter float32
	specular        float32
}

type SphereSimple struct {
	center Vector
	radius float32
	color  color.RGBA
}

func Distance(v1, v2 Vector, radius float32) float32 {
	// Use vector subtraction and dot product instead of individual calculations
	diff := v1.Sub(v2)
	return diff.Length() - radius
}

// Add normal calculation for spheres
func calculateNormal(point, center Vector) Vector {
	return point.Sub(center).Normalize()
}

type RayMarchingBVH struct {
	BoundingBox [2]Vector
	Sphere      *SphereSimple
	Left, Right *RayMarchingBVH
	Active      bool
}

func calculateSphereSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func calculateSphereBoundingBox(sphere SphereSimple) [2]Vector {
	return [2]Vector{
		{
			x: sphere.center.x - sphere.radius,
			y: sphere.center.y - sphere.radius,
			z: sphere.center.z - sphere.radius,
		},
		{
			x: sphere.center.x + sphere.radius,
			y: sphere.center.y + sphere.radius,
			z: sphere.center.z + sphere.radius,
		},
	}
}

func BuildBvhForSpheres(spheres []SphereSimple, maxDepth int) *RayMarchingBVH {
	if len(spheres) == 0 {
		return nil
	}

	// Calculate the overall bounding box
	boundingBox := [2]Vector{
		{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
		{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
	}

	for _, sphere := range spheres {
		sphereBBox := calculateSphereBoundingBox(sphere)
		boundingBox[0].x = float32(math.Min(float64(boundingBox[0].x), float64(sphereBBox[0].x)))
		boundingBox[0].y = float32(math.Min(float64(boundingBox[0].y), float64(sphereBBox[0].y)))
		boundingBox[0].z = float32(math.Min(float64(boundingBox[0].z), float64(sphereBBox[0].z)))

		boundingBox[1].x = float32(math.Max(float64(boundingBox[1].x), float64(sphereBBox[1].x)))
		boundingBox[1].y = float32(math.Max(float64(boundingBox[1].y), float64(sphereBBox[1].y)))
		boundingBox[1].z = float32(math.Max(float64(boundingBox[1].z), float64(sphereBBox[1].z)))
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(spheres) <= 1 || maxDepth <= 0 {
		node := &RayMarchingBVH{
			BoundingBox: boundingBox,
			Sphere: &SphereSimple{
				center: spheres[0].center,
				radius: spheres[0].radius,
				color:  spheres[0].color,
			},
			Active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort spheres along the current axis
		switch axis {
		case 0:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.x < spheres[j].center.x
			})
		case 1:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.y < spheres[j].center.y
			})
		case 2:
			sort.Slice(spheres, func(i, j int) bool {
				return spheres[i].center.z < spheres[j].center.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(spheres); i++ {
			leftBBox := [2]Vector{
				{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
				{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math.MaxFloat32, math.MaxFloat32, math.MaxFloat32},
				{-math.MaxFloat32, -math.MaxFloat32, -math.MaxFloat32},
			}

			// Calculate left bounding box
			for j := 0; j < i; j++ {
				sphereBBox := calculateSphereBoundingBox(spheres[j])
				leftBBox[0].x = float32(math.Min(float64(leftBBox[0].x), float64(sphereBBox[0].x)))
				leftBBox[0].y = float32(math.Min(float64(leftBBox[0].y), float64(sphereBBox[0].y)))
				leftBBox[0].z = float32(math.Min(float64(leftBBox[0].z), float64(sphereBBox[0].z)))
				leftBBox[1].x = float32(math.Max(float64(leftBBox[1].x), float64(sphereBBox[1].x)))
				leftBBox[1].y = float32(math.Max(float64(leftBBox[1].y), float64(sphereBBox[1].y)))
				leftBBox[1].z = float32(math.Max(float64(leftBBox[1].z), float64(sphereBBox[1].z)))
			}

			// Calculate right bounding box
			for j := i; j < len(spheres); j++ {
				sphereBBox := calculateSphereBoundingBox(spheres[j])
				rightBBox[0].x = float32(math.Min(float64(rightBBox[0].x), float64(sphereBBox[0].x)))
				rightBBox[0].y = float32(math.Min(float64(rightBBox[0].y), float64(sphereBBox[0].y)))
				rightBBox[0].z = float32(math.Min(float64(rightBBox[0].z), float64(sphereBBox[0].z)))
				rightBBox[1].x = float32(math.Max(float64(rightBBox[1].x), float64(sphereBBox[1].x)))
				rightBBox[1].y = float32(math.Max(float64(rightBBox[1].y), float64(sphereBBox[1].y)))
				rightBBox[1].z = float32(math.Max(float64(rightBBox[1].z), float64(sphereBBox[1].z)))
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSphereSurfaceArea(leftBBox) + float32(len(spheres)-i)*calculateSphereSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort spheres along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.x < spheres[j].center.x
		})
	case 1:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.y < spheres[j].center.y
		})
	case 2:
		sort.Slice(spheres, func(i, j int) bool {
			return spheres[i].center.z < spheres[j].center.z
		})
	}

	// Create the BVH node with the best split
	node := &RayMarchingBVH{BoundingBox: boundingBox}
	node.Left = BuildBvhForSpheres(spheres[:bestSplit], maxDepth-1)
	node.Right = BuildBvhForSpheres(spheres[bestSplit:], maxDepth-1)

	return node
}

var sphereBVH = RayMarchingBVH{}

func IntersectBVH_RayMarching(bvh RayMarchingBVH, ray Ray) (bool, *SphereSimple) {
	if !BoundingBoxCollision(bvh.BoundingBox, &ray) {
		return false, nil
	}

	if bvh.Sphere != nil {
		return true, bvh.Sphere
	}

	hitLeft, left := IntersectBVH_RayMarching(*bvh.Left, ray)
	hitRight, right := IntersectBVH_RayMarching(*bvh.Right, ray)

	if hitLeft && hitRight {
		if Distance(ray.origin, left.center, left.radius) < Distance(ray.origin, right.center, right.radius) {
			return true, left
		}
		return true, right
	}

	if hitLeft {
		return true, left
	}

	if hitRight {
		return true, right
	}

	return false, nil
}

// Improved sphere conversion with pre-allocated slice
func (obj object) ConvertToSquare(count int) []SphereSimple {
	spheres := make([]SphereSimple, 0, count)

	for i := 0; i < count; i += 1 {
		randIndex := rand.Intn(len(obj.triangles))
		R := clampUint8(obj.triangles[randIndex].color.R)
		G := clampUint8(obj.triangles[randIndex].color.G)
		B := clampUint8(obj.triangles[randIndex].color.B)
		spheres = append(spheres, SphereSimple{
			center: obj.triangles[randIndex].v1,
			radius: 2,
			// color:  obj.triangles[randIndex].color,
			color: color.RGBA{R, G, B, 255},
		})
	}
	return spheres
}

func RayMarchBvh(ray Ray, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
	)

	var (
		totalDistance float32
		closestSphere *SphereSimple
		currentPoint  Vector
	)

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		hit, sphere := IntersectBVH_RayMarching(sphereBVH, ray)
		if hit {
			minDistance = Distance(currentPoint, sphere.center, sphere.radius)
			closestSphere = sphere
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, *closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, *closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

func RayMarching(ray Ray, spheres []SphereSimple, iterations int, light Light) (color.RGBA, float32) {
	const (
		EPSILON      = float32(0.0001)
		MAX_DISTANCE = float32(10000.0)
	)

	var (
		totalDistance float32
		sphereColor   = color.RGBA{0, 0, 0, 255}
		closestSphere SphereSimple
		currentPoint  Vector
	)

	// Early exit if no spheres
	if len(spheres) == 0 {
		return sphereColor, totalDistance
	}

	for i := 0; i < iterations; i++ {
		currentPoint = ray.origin.Add(ray.direction.Mul(totalDistance))
		minDistance := MAX_DISTANCE

		// Find closest sphere
		for _, sphere := range spheres {
			if dist := Distance(currentPoint, sphere.center, sphere.radius); dist < minDistance {
				minDistance = dist
				closestSphere = sphere
			}
		}

		totalDistance += minDistance

		// Hit detection with early exit
		if minDistance < EPSILON {
			return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
		}

		// Miss detection with early exit
		if minDistance > MAX_DISTANCE || totalDistance > MAX_DISTANCE {
			return color.RGBA{0, 0, 0, 0}, totalDistance
		}
	}

	return calculateShading(currentPoint, closestSphere, totalDistance, MAX_DISTANCE, light), totalDistance
}

// Helper function for color shading calculations
func calculateShading(point Vector, sphere SphereSimple, totalDistance, maxDistance float32, light Light) color.RGBA {

	// Calculate normal at intersection point
	normal := calculateNormal(point, sphere.center)

	// Calculate light direction
	lightDir := light.Position.Sub(point).Normalize()

	// Ambient component
	ambientStrength := float32(0.1)
	ambient := float32(sphere.color.R) * ambientStrength

	// Diffuse component
	diff := max(normal.Dot(lightDir), 0.0)
	diffuse := diff * float32(sphere.color.R)

	// Specular component
	specularStrength := float32(0.5)
	viewDir := point.Mul(-1).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(normal)
	spec := math32.Pow(max(viewDir.Dot(reflectDir), 0.0), 32)
	specular := specularStrength * spec

	// Distance attenuation
	// attenuation := maxDistance / totalDistance

	// Combine components
	final := min((ambient + diffuse + specular), 255)

	return color.RGBA{
		R: uint8(final / 255 * float32(sphere.color.R)),
		G: uint8(final / 255 * float32(sphere.color.G)),
		B: uint8(final / 255 * float32(sphere.color.B)),
		A: 255,
	}
}

func (t *TriangleSimple) CalculateNormal() {
	edge1 := t.v2.Sub(t.v1)
	edge2 := t.v3.Sub(t.v1)
	t.Normal = edge1.Cross(edge2).Normalize()
}

func BoundingBoxCollision(BoundingBox [2]Vector, ray *Ray) bool {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))
	return tmax >= max(0.0, tmin)
}

func BoundingBoxCollisionDistance(BoundingBox [2]Vector, ray Ray) (bool, float32) {
	// Precompute the inverse direction
	invDirX := 1.0 / ray.direction.x
	invDirY := 1.0 / ray.direction.y
	invDirZ := 1.0 / ray.direction.z

	// Compute the tmin and tmax for each axis directly
	tx1 := (BoundingBox[0].x - ray.origin.x) * invDirX
	tx2 := (BoundingBox[1].x - ray.origin.x) * invDirX
	tmin := min(tx1, tx2)
	tmax := max(tx1, tx2)

	ty1 := (BoundingBox[0].y - ray.origin.y) * invDirY
	ty2 := (BoundingBox[1].y - ray.origin.y) * invDirY
	tmin = max(tmin, min(ty1, ty2))
	tmax = min(tmax, max(ty1, ty2))

	tz1 := (BoundingBox[0].z - ray.origin.z) * invDirZ
	tz2 := (BoundingBox[1].z - ray.origin.z) * invDirZ
	tmin = max(tmin, min(tz1, tz2))
	tmax = min(tmax, max(tz1, tz2))

	// Final intersection check
	if tmax >= max(0.0, tmin) {
		return true, tmin
	}

	return false, 0.0 // Return 0 distance if no intersection
}

func (triangle *TriangleSimple) Rotate(xAngle, yAngle, zAngle float32) {
	// Rotation matrices
	rotationMatrixX := [3][3]float32{
		{1, 0, 0},
		{0, math32.Cos(xAngle), -math32.Sin(xAngle)},
		{0, math32.Sin(xAngle), math32.Cos(xAngle)},
	}

	rotationMatrixY := [3][3]float32{
		{math32.Cos(yAngle), 0, math32.Sin(yAngle)},
		{0, 1, 0},
		{-math32.Sin(yAngle), 0, math32.Cos(yAngle)},
	}

	rotationMatrixZ := [3][3]float32{
		{math32.Cos(zAngle), -math32.Sin(zAngle), 0},
		{math32.Sin(zAngle), math32.Cos(zAngle), 0},
		{0, 0, 1},
	}

	// Apply the rotation matrices to each vertex
	triangle.v1 = rotateVector(triangle.v1, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v2 = rotateVector(triangle.v2, rotationMatrixX, rotationMatrixY, rotationMatrixZ)
	triangle.v3 = rotateVector(triangle.v3, rotationMatrixX, rotationMatrixY, rotationMatrixZ)

	// Recalculate the bounding box
	triangle.CalculateBoundingBox()
}

func rotateVector(v Vector, rotationMatrixX, rotationMatrixY, rotationMatrixZ [3][3]float32) Vector {
	v = applyRotationMatrix(v, rotationMatrixX)
	v = applyRotationMatrix(v, rotationMatrixY)
	v = applyRotationMatrix(v, rotationMatrixZ)
	return v
}

func applyRotationMatrix(v Vector, matrix [3][3]float32) Vector {
	return Vector{
		x: matrix[0][0]*v.x + matrix[0][1]*v.y + matrix[0][2]*v.z,
		y: matrix[1][0]*v.x + matrix[1][1]*v.y + matrix[1][2]*v.z,
		z: matrix[2][0]*v.x + matrix[2][1]*v.y + matrix[2][2]*v.z,
	}
}

func CreateCube(center Vector, size float32, color ColorFloat32, refection float32, specular float32) []TriangleSimple {
	halfSize := size / 2

	vertices := [8]Vector{
		{center.x - halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y - halfSize, center.z - halfSize},
		{center.x + halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y + halfSize, center.z - halfSize},
		{center.x - halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y - halfSize, center.z + halfSize},
		{center.x + halfSize, center.y + halfSize, center.z + halfSize},
		{center.x - halfSize, center.y + halfSize, center.z + halfSize},
	}

	return []TriangleSimple{
		NewTriangle(vertices[0], vertices[1], vertices[2], color, refection, specular), // Front face
		NewTriangle(vertices[0], vertices[2], vertices[3], color, refection, specular),

		NewTriangle(vertices[4], vertices[5], vertices[6], color, refection, specular), // Back face
		NewTriangle(vertices[4], vertices[6], vertices[7], color, refection, specular),

		NewTriangle(vertices[0], vertices[1], vertices[5], color, refection, specular), // Bottom face
		NewTriangle(vertices[0], vertices[5], vertices[4], color, refection, specular),

		NewTriangle(vertices[2], vertices[3], vertices[7], color, refection, specular), // Top face
		NewTriangle(vertices[2], vertices[7], vertices[6], color, refection, specular),

		NewTriangle(vertices[1], vertices[2], vertices[6], color, refection, specular), // Right face
		NewTriangle(vertices[1], vertices[6], vertices[5], color, refection, specular),

		NewTriangle(vertices[0], vertices[3], vertices[7], color, refection, specular), // Left face
		NewTriangle(vertices[0], vertices[7], vertices[4], color, refection, specular),
	}
}

func CreatePlane(center Vector, normal Vector, width, height float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	// Calculate the tangent vectors
	var tangent, bitangent Vector
	if math32.Abs(normal.x) > math32.Abs(normal.y) {
		tangent = Vector{normal.z, 0, -normal.x}.Normalize()
	} else {
		tangent = Vector{0, -normal.z, normal.y}.Normalize()
	}
	bitangent = normal.Cross(tangent)

	// Calculate the corner vertices
	halfWidth := width / 2
	halfHeight := height / 2
	v1 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(-halfHeight))
	v2 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(-halfHeight))
	v3 := center.Add(tangent.Mul(halfWidth)).Add(bitangent.Mul(halfHeight))
	v4 := center.Add(tangent.Mul(-halfWidth)).Add(bitangent.Mul(halfHeight))

	return []TriangleSimple{
		NewTriangle(v1, v2, v3, color, reflection, specular),
		NewTriangle(v1, v3, v4, color, reflection, specular),
	}
}

func CreateSphere(center Vector, radius float32, color ColorFloat32, reflection float32, specular float32) []TriangleSimple {
	var triangles []TriangleSimple
	latitudeBands := 20
	longitudeBands := 20

	for lat := 0; lat < latitudeBands; lat++ {
		for long := 0; long < longitudeBands; long++ {
			lat0 := math.Pi * float64(-0.5+float32(lat)/float32(latitudeBands))
			z0 := math32.Sin(float32(lat0)) * radius
			zr0 := math32.Cos(float32(lat0)) * radius

			lat1 := math.Pi * float64(-0.5+float32(lat+1)/float32(latitudeBands))
			z1 := math32.Sin(float32(lat1)) * radius
			zr1 := math32.Cos(float32(lat1)) * radius

			lng0 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x0 := math32.Cos(float32(lng0)) * zr0
			y0 := math32.Sin(float32(lng0)) * zr0

			lng1 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x1 := math32.Cos(float32(lng1)) * zr0
			y1 := math32.Sin(float32(lng1)) * zr0

			lng2 := 2 * math.Pi * float64(float32(long)/float32(longitudeBands))
			x2 := math32.Cos(float32(lng2)) * zr1
			y2 := math32.Sin(float32(lng2)) * zr1

			lng3 := 2 * math.Pi * float64(float32(long+1)/float32(longitudeBands))
			x3 := math32.Cos(float32(lng3)) * zr1
			y3 := math32.Sin(float32(lng3)) * zr1

			triangles = append(triangles, NewTriangle(Vector{x0 + center.x, y0 + center.y, z0 + center.z}, Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
			triangles = append(triangles, NewTriangle(Vector{x1 + center.x, y1 + center.y, z0 + center.z}, Vector{x3 + center.x, y3 + center.y, z1 + center.z}, Vector{x2 + center.x, y2 + center.y, z1 + center.z}, color, reflection, specular))
		}
	}

	return triangles
}

// func (triangle *Triangle) CalculateBoundingBox() {
// 	// Compute the minimum and maximum coordinates using float32 functions
// 	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
// 	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
// 	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
// 	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
// 	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
// 	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

// 	// Set the BoundingBox with computed min and max values
// 	triangle.BoundingBox[0] = Vector{minX, minY, minZ}
// 	triangle.BoundingBox[1] = Vector{maxX, maxY, maxZ}
// }

func (triangle TriangleSimple) CalculateBoundingBox() (minBox Vector, maxBox Vector) {
	// Compute the minimum and maximum coordinates using float32 functions
	minX := math32.Min(triangle.v1.x, math32.Min(triangle.v2.x, triangle.v3.x))
	minY := math32.Min(triangle.v1.y, math32.Min(triangle.v2.y, triangle.v3.y))
	minZ := math32.Min(triangle.v1.z, math32.Min(triangle.v2.z, triangle.v3.z))
	maxX := math32.Max(triangle.v1.x, math32.Max(triangle.v2.x, triangle.v3.x))
	maxY := math32.Max(triangle.v1.y, math32.Max(triangle.v2.y, triangle.v3.y))
	maxZ := math32.Max(triangle.v1.z, math32.Max(triangle.v2.z, triangle.v3.z))

	// Set the BoundingBox with computed min and max values
	return Vector{minX, minY, minZ}, Vector{maxX, maxY, maxZ}
}

func NewTriangle(v1, v2, v3 Vector, color ColorFloat32, reflection float32, specular float32) TriangleSimple {
	triangle := TriangleSimple{v1: v1, v2: v2, v3: v3, color: color, reflection: reflection, specular: specular, directToScatter: 0.5}
	triangle.CalculateBoundingBox()
	triangle.CalculateNormal()
	return triangle
}

// func (triangle *Triangle) IntersectBoundingBox(ray Ray) bool {
// 	// Precompute the inverse direction
// 	invDirX := 1.0 / ray.direction.x
// 	invDirY := 1.0 / ray.direction.y
// 	invDirZ := 1.0 / ray.direction.z

// 	// Compute the tmin and tmax for each axis directly
// 	tx1 := (triangle.BoundingBox[0].x - ray.origin.x) * invDirX
// 	tx2 := (triangle.BoundingBox[1].x - ray.origin.x) * invDirX
// 	tmin := min(tx1, tx2)
// 	tmax := max(tx1, tx2)

// 	ty1 := (triangle.BoundingBox[0].y - ray.origin.y) * invDirY
// 	ty2 := (triangle.BoundingBox[1].y - ray.origin.y) * invDirY
// 	tmin = max(tmin, min(ty1, ty2))
// 	tmax = min(tmax, max(ty1, ty2))

// 	tz1 := (triangle.BoundingBox[0].z - ray.origin.z) * invDirZ
// 	tz2 := (triangle.BoundingBox[1].z - ray.origin.z) * invDirZ
// 	tmin = max(tmin, min(tz1, tz2))
// 	tmax = min(tmax, max(tz1, tz2))

// 	// Final intersection check
// 	return tmax >= max(0.0, tmin)
// }

type Intersection struct {
	PointOfIntersection Vector
	Color               ColorFloat32
	Normal              Vector
	Direction           Vector
	Distance            float32
	reflection          float32
	directToScatter     float32
	specular            float32
}

type Light struct {
	Position  *Vector
	Color     *[3]float32
	intensity float32
}

// func (light *Light) CalculateLighting(intersection Intersection, bvh *BVHNode) color.RGBA {
// 	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
// 	shadowRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: lightDir}

// 	// Check if the point is in shadow
// 	inShadow := false
// 	if _, intersect := shadowRay.IntersectBVH(bvh); intersect {
// 		inShadow = true
// 	}

// 	// Ambient light contribution
// 	ambientFactor := 0.05 // Adjust ambient factor as needed
// 	ambientColor := color.RGBA{
// 		uint8(float64(light.Color.R) * ambientFactor),
// 		uint8(float64(light.Color.G) * ambientFactor),
// 		uint8(float64(light.Color.B) * ambientFactor),
// 		light.Color.A,
// 	}

// 	if inShadow {
// 		// If in shadow, return ambient color
// 		return ambientColor
// 	}

// 	// Calculate diffuse lighting
// 	lightIntensity := light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
// 	finalColor := color.RGBA{
// 		clampUint8(float32(ambientColor.R) + lightIntensity*float32(intersection.Color.R)),
// 		clampUint8(float32(ambientColor.G) + lightIntensity*float32(intersection.Color.G)),
// 		clampUint8(float32(ambientColor.B) + lightIntensity*float32(intersection.Color.B)),
// 		ambientColor.A,
// 	}

// 	return finalColor
// }

// Helper function to clamp a float64 value to uint8 range
func clampUint8(value float32) uint8 {
	if value < 0 {
		return 0
	}
	if value > 255 {
		return 255
	}
	return uint8(value)
}

// var Old time.Duration
// var OldCount int64
// var New time.Duration
// var NewCount int64

// Intersect BVH average time: 497ns
// func (ray *Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
// 	if nodeBVH.Triangles != nil {
// 		return IntersectTriangles(*ray, *nodeBVH.Triangles)
// 	}

// 	leftHit := nodeBVH.Left != nil && BoundingBoxCollision(nodeBVH.Left.BoundingBox, ray)
// 	rightHit := nodeBVH.Right != nil && BoundingBoxCollision(nodeBVH.Right.BoundingBox, ray)

// 	if leftHit && rightHit {
// 		leftIntersection, leftIntersect := ray.IntersectBVH(nodeBVH.Left)
// 		rightIntersection, rightIntersect := ray.IntersectBVH(nodeBVH.Right)

// 		if leftIntersect && rightIntersect {
// 			if leftIntersection.Distance < rightIntersection.Distance {
// 				return leftIntersection, true
// 			}
// 			return rightIntersection, true
// 		} else if leftIntersect {
// 			return leftIntersection, true
// 		} else if rightIntersect {
// 			return rightIntersection, true
// 		}
// 	} else if leftHit {
// 		return ray.IntersectBVH(nodeBVH.Left)
// 	} else if rightHit {
// 		return ray.IntersectBVH(nodeBVH.Right)
// 	}
// 	return Intersection{}, false
// }

// Intersect BVH average time:  458ns
func (ray Ray) IntersectBVH(nodeBVH *BVHNode) (Intersection, bool) {
	// Preallocate a stack large enough for the BVH depth
	stack := make([]*BVHNode, maxDepth)
	stackIndex := 0
	stack[stackIndex] = nodeBVH
	var closestIntersection Intersection
	hit := false

	for stackIndex >= 0 {
		// Pop the top item from the stack
		currentNode := stack[stackIndex]
		stackIndex--

		// If the node contains triangles, check for intersections
		if currentNode.active {
			// intersection, intersects := IntersectTrianglesSimple(*ray, *currentNode.Triangles)
			intersection, intersects := ray.IntersectTriangleSimple(currentNode.Triangles)
			if intersects {
				if !hit || intersection.Distance < closestIntersection.Distance {
					closestIntersection = intersection
					hit = true
				}
			}
			continue
		}
		// Check for bounding box intersections for left and right children
		var leftHit, rightHit bool
		var leftDist, rightDist float32

		if currentNode.Left != nil {
			leftHit, leftDist = BoundingBoxCollisionDistance(currentNode.Left.BoundingBox, ray)
		}
		if currentNode.Right != nil {
			rightHit, rightDist = BoundingBoxCollisionDistance(currentNode.Right.BoundingBox, ray)
		}

		// Prioritize traversal based on hit distance (closer node first)
		if leftHit && rightHit {
			if leftDist < rightDist {
				// Left is closer, traverse left first
				stackIndex++
				stack[stackIndex] = currentNode.Right
				stackIndex++
				stack[stackIndex] = currentNode.Left
			} else {
				// Right is closer, traverse right first
				stackIndex++
				stack[stackIndex] = currentNode.Left
				stackIndex++
				stack[stackIndex] = currentNode.Right
			}
		} else if leftHit {
			// Only left child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Left
		} else if rightHit {
			// Only right child is hit
			stackIndex++
			stack[stackIndex] = currentNode.Right
		}
	}

	return closestIntersection, hit
}

// func (ray *Ray) IntersectTriangle(triangle Triangle) (Intersection, bool) {
// 	// Check if the ray intersects the bounding box of the triangle first
// 	if !triangle.IntersectBoundingBox(*ray) {
// 		return Intersection{}, false
// 	}

// 	// Möller–Trumbore intersection algorithm
// 	edge1 := triangle.v2.Sub(triangle.v1)
// 	edge2 := triangle.v3.Sub(triangle.v1)
// 	h := ray.direction.Cross(edge2)
// 	a := edge1.Dot(h)
// 	if a > -0.00001 && a < 0.00001 {
// 		return Intersection{}, false
// 	}
// 	f := 1.0 / a
// 	s := ray.origin.Sub(triangle.v1)
// 	u := f * s.Dot(h)
// 	if u < 0.0 || u > 1.0 {
// 		return Intersection{}, false
// 	}
// 	q := s.Cross(edge1)
// 	v := f * ray.direction.Dot(q)
// 	if v < 0.0 || u+v > 1.0 {
// 		return Intersection{}, false
// 	}
// 	t := f * edge2.Dot(q)
// 	if t > 0.00001 {
// 		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection}, true
// 	}
// 	return Intersection{}, false
// }

func (ray *Ray) IntersectTriangleSimple(triangle TriangleSimple) (Intersection, bool) {
	// Möller–Trumbore intersection algorithm
	edge1 := triangle.v2.Sub(triangle.v1)
	edge2 := triangle.v3.Sub(triangle.v1)
	h := ray.direction.Cross(edge2)
	a := edge1.Dot(h)
	if a > -0.00001 && a < 0.00001 {
		return Intersection{}, false
	}
	f := 1.0 / a
	s := ray.origin.Sub(triangle.v1)
	u := f * s.Dot(h)
	if u < 0.0 || u > 1.0 {
		return Intersection{}, false
	}
	q := s.Cross(edge1)
	v := f * ray.direction.Dot(q)
	if v < 0.0 || u+v > 1.0 {
		return Intersection{}, false
	}
	t := f * edge2.Dot(q)
	if t > 0.00001 {
		return Intersection{PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)), Color: triangle.color, Normal: triangle.Normal, Direction: ray.direction, Distance: t, reflection: triangle.reflection, directToScatter: triangle.directToScatter}, true
	}
	return Intersection{}, false
}

// func IntersectTriangles(ray Ray, triangles []Triangle) (Intersection, bool) {
// 	// Initialize the closest intersection and hit status
// 	closestIntersection := Intersection{Distance: math32.MaxFloat32}
// 	hasIntersection := false

// 	// Iterate over each triangle for the given ray
// 	for _, triangle := range triangles {
// 		// Check if the ray intersects the bounding box of the triangle first
// 		if !triangle.IntersectBoundingBox(ray) {
// 			continue
// 		}

// 		// Möller–Trumbore intersection algorithm
// 		edge1 := triangle.v2.Sub(triangle.v1)
// 		edge2 := triangle.v3.Sub(triangle.v1)
// 		h := ray.direction.Cross(edge2)
// 		a := edge1.Dot(h)
// 		if a > -0.00001 && a < 0.00001 {
// 			continue
// 		}
// 		f := 1.0 / a
// 		s := ray.origin.Sub(triangle.v1)
// 		u := f * s.Dot(h)
// 		if u < 0.0 || u > 1.0 {
// 			continue
// 		}
// 		q := s.Cross(edge1)
// 		v := f * ray.direction.Dot(q)
// 		if v < 0.0 || u+v > 1.0 {
// 			continue
// 		}
// 		t := f * edge2.Dot(q)
// 		if t > 0.00001 {
// 			tempIntersection := Intersection{
// 				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
// 				Color:               triangle.color,
// 				Normal:              triangle.Normal,
// 				Direction:           ray.direction,
// 				Distance:            t,
// 				reflection:          triangle.reflection,
// 				specular:            triangle.specular,
// 			}

// 			// Update the closest intersection if the new one is closer
// 			if t < closestIntersection.Distance {
// 				closestIntersection = tempIntersection
// 				hasIntersection = true
// 			}
// 		}
// 	}

// 	return closestIntersection, hasIntersection
// }

func IntersectTrianglesSimple(ray Ray, triangles []TriangleSimple) (Intersection, bool) {
	// Initialize the closest intersection and hit status
	closestIntersection := Intersection{Distance: math32.MaxFloat32}
	hasIntersection := false

	// Iterate over each triangle for the given ray
	for _, triangle := range triangles {
		// Möller–Trumbore intersection algorithm
		edge1 := triangle.v2.Sub(triangle.v1)
		edge2 := triangle.v3.Sub(triangle.v1)
		h := ray.direction.Cross(edge2)
		a := edge1.Dot(h)
		if a > -0.00001 && a < 0.00001 {
			continue
		}
		f := 1.0 / a
		s := ray.origin.Sub(triangle.v1)
		u := f * s.Dot(h)
		if u < 0.0 || u > 1.0 {
			continue
		}
		q := s.Cross(edge1)
		v := f * ray.direction.Dot(q)
		if v < 0.0 || u+v > 1.0 {
			continue
		}
		t := f * edge2.Dot(q)
		if t > 0.00001 {
			tempIntersection := Intersection{
				PointOfIntersection: ray.origin.Add(ray.direction.Mul(t)),
				Color:               triangle.color,
				Normal:              triangle.Normal,
				Direction:           ray.direction,
				Distance:            t,
				reflection:          triangle.reflection,
				specular:            triangle.specular,
				directToScatter:     triangle.directToScatter,
			}

			// Update the closest intersection if the new one is closer
			if t < closestIntersection.Distance {
				closestIntersection = tempIntersection
				hasIntersection = true
			}
		}
	}

	return closestIntersection, hasIntersection
}

type Camera struct {
	Position     Vector
	xAxis, yAxis float32
}

func TraceRay(ray Ray, depth int, light Light, samples int) ColorFloat32 {
	if depth == 0 {
		return ColorFloat32{}
	}

	intersection, intersect := ray.IntersectBVH(BVH)
	if !intersect {
		return ColorFloat32{}
	}

	// Scatter calculation
	var scatteredRed, scatteredGreen, scatteredBlue float32
	uVec := Vector{1.0, 0.0, 0.0}
	if math32.Abs(intersection.Normal.x) > 0.1 {
		uVec = Vector{0.0, 1.0, 0.0}
	}
	uVec = uVec.Cross(intersection.Normal).Normalize()
	vVec := intersection.Normal.Cross(uVec)

	for i := 0; i < samples; i++ {
		u := rand.Float32()
		v := rand.Float32()
		r := math32.Sqrt(u)
		theta := 2 * math32.Pi * v

		directionLocal := uVec.Mul(r * math32.Cos(theta)).Add(vVec.Mul(r * math32.Sin(theta))).Add(intersection.Normal.Mul(math32.Sqrt(1 - u)))

		scatterRay := Ray{origin: intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001)), direction: directionLocal.Normalize()}

		if bvhIntersection, scatterIntersect := scatterRay.IntersectBVH(BVH); scatterIntersect && bvhIntersection.Distance != math32.MaxFloat32 {
			scatteredRed += float32(bvhIntersection.Color.R)
			scatteredGreen += float32(bvhIntersection.Color.G)
			scatteredBlue += float32(bvhIntersection.Color.B)
		}
	}

	if samples > 0 {
		s := float32(samples)
		scatteredRed /= s
		scatteredGreen /= s
		scatteredBlue /= s
	}

	ratioScatterToDirect := 1 - intersection.reflection
	scatteredColor := ColorFloat32{
		R: scatteredRed * ratioScatterToDirect,
		G: scatteredGreen * ratioScatterToDirect,
		B: scatteredBlue * ratioScatterToDirect,
		A: float32(intersection.Color.A),
	}

	// Reflection and specular calculations
	lightDir := light.Position.Sub(intersection.PointOfIntersection).Normalize()
	reflectDir := lightDir.Mul(-1).Reflect(intersection.Normal)

	reflectRayOrigin := intersection.PointOfIntersection.Add(intersection.Normal.Mul(0.001))

	reflectRay := Ray{origin: reflectRayOrigin, direction: reflectDir}

	tempIntersection, _ := reflectRay.IntersectBVH(BVH)

	directReflectionColor := ColorFloat32{
		R: tempIntersection.Color.R * intersection.reflection,
		G: tempIntersection.Color.G * intersection.reflection,
		B: tempIntersection.Color.B * intersection.reflection,
		A: intersection.Color.A,
	}

	shadowRay := Ray{
		origin:    reflectRayOrigin,
		direction: lightDir,
	}
	_, inShadow := shadowRay.IntersectBVH(BVH)

	viewDir := ray.origin.Sub(intersection.PointOfIntersection).Normalize()
	specularFactor := math32.Pow(math32.Max(0.0, viewDir.Dot(reflectDir)), intersection.specular)
	specularIntensity := light.intensity * specularFactor

	var lightIntensity = float32(0.005)
	if !inShadow {
		lightIntensity = light.intensity * math32.Max(0.0, lightDir.Dot(intersection.Normal))
	}

	finalColor := ColorFloat32{
		R: ((directReflectionColor.R + scatteredColor.R) * (1 - intersection.directToScatter)) + ((intersection.Color.R) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		G: ((directReflectionColor.G + scatteredColor.G) * (1 - intersection.directToScatter)) + ((intersection.Color.G) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		B: ((directReflectionColor.B + scatteredColor.B) * (1 - intersection.directToScatter)) + ((intersection.Color.B) * intersection.directToScatter) + (specularIntensity*(light.Color[0]))*lightIntensity*light.Color[0],
		A: float32(intersection.Color.A),
	}

	bounceRay := Ray{origin: reflectRayOrigin, direction: reflectDir}
	bouncedColor := TraceRay(bounceRay, depth-1, light, samples)

	Color := ColorFloat32{
		R: (finalColor.R*intersection.directToScatter + (float32(bouncedColor.R) * (1 - intersection.directToScatter))),
		G: (finalColor.G*intersection.directToScatter + (float32(bouncedColor.G) * (1 - intersection.directToScatter))),
		B: (finalColor.B*intersection.directToScatter + (float32(bouncedColor.B) * (1 - intersection.directToScatter))),
		A: finalColor.A,
	}

	// Color := color.RGBA{
	// 	R: clampUint8((finalColor.R + float32(bouncedColor.R)) / 2),
	// 	G: clampUint8((finalColor.G + float32(bouncedColor.G)) / 2),
	// 	B: clampUint8((finalColor.B + float32(bouncedColor.B)) / 2),
	// 	A: uint8(finalColor.A),
	// }

	return Color
}

type object struct {
	triangles   []TriangleSimple
	BoundingBox [2]Vector
}

func ConvertObjectsToBVH(objects []object, maxDepth int) *BVHNode {
	Triangles := []TriangleSimple{}
	for _, object := range objects {
		Triangles = append(Triangles, object.triangles...)
	}
	return buildBVHNode(Triangles, 0, maxDepth)
}

type BVHNode struct {
	Left, Right *BVHNode
	BoundingBox [2]Vector
	Triangles   TriangleSimple
	active      bool
}

func (object *object) BuildBVH(maxDepth int) *BVHNode {
	return buildBVHNode(object.triangles, 0, maxDepth)
}

func calculateSurfaceArea(bbox [2]Vector) float32 {
	dx := bbox[1].x - bbox[0].x
	dy := bbox[1].y - bbox[0].y
	dz := bbox[1].z - bbox[0].z
	return 2 * (dx*dy + dy*dz + dz*dx)
}

func buildBVHNode(triangles []TriangleSimple, depth int, maxDepth int) *BVHNode {
	if len(triangles) == 0 {
		return nil
	}

	// Calculate the bounding box of the node
	boundingBox := [2]Vector{
		{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
		{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
	}

	for _, triangle := range triangles {
		minBox, maxBox := triangle.CalculateBoundingBox()
		boundingBox[0].x = math32.Min(boundingBox[0].x, minBox.x)
		boundingBox[0].y = math32.Min(boundingBox[0].y, minBox.y)
		boundingBox[0].z = math32.Min(boundingBox[0].z, minBox.z)

		boundingBox[1].x = math32.Max(boundingBox[1].x, maxBox.x)
		boundingBox[1].y = math32.Max(boundingBox[1].y, maxBox.y)
		boundingBox[1].z = math32.Max(boundingBox[1].z, maxBox.z)
	}

	// If the node is a leaf or we've reached the maximum depth
	if len(triangles) <= 1 || depth >= maxDepth {
		// Allocate the slice with the exact capacity needed
		// trianglesSimple := make([]TriangleSimple, len(triangles))
		// for i, triangle := range triangles {

		node := &BVHNode{
			BoundingBox: boundingBox,
			Triangles: TriangleSimple{
				v1: triangles[0].v1,
				v2: triangles[0].v2,
				v3: triangles[0].v3,
				color: ColorFloat32{
					R: triangles[0].color.R,
					G: triangles[0].color.G,
					B: triangles[0].color.B,
					A: triangles[0].color.A,
				},
				Normal:          triangles[0].Normal,
				reflection:      triangles[0].reflection,
				specular:        triangles[0].specular,
				directToScatter: 0.5,
			},
			active: true,
		}
		return node
	}

	// Surface Area Heuristics (SAH) to find the best split
	bestCost := float32(math32.MaxFloat32)
	bestSplit := -1
	bestAxis := 0

	for axis := 0; axis < 3; axis++ {
		// Sort the triangles along the current axis
		switch axis {
		case 0:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.x < jMinBox.x
			})
		case 1:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.y < jMinBox.y
			})
		case 2:
			sort.Slice(triangles, func(i, j int) bool {
				iMinBox, _ := triangles[i].CalculateBoundingBox()
				jMinBox, _ := triangles[j].CalculateBoundingBox()
				return iMinBox.z < jMinBox.z
			})
		}

		// Compute surface area for all possible splits
		for i := 1; i < len(triangles); i++ {
			leftBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}
			rightBBox := [2]Vector{
				{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
				{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
			}

			for j := 0; j < i; j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				leftBBox[0].x = math32.Min(leftBBox[0].x, jMinBox.x)
				leftBBox[0].y = math32.Min(leftBBox[0].y, jMinBox.y)
				leftBBox[0].z = math32.Min(leftBBox[0].z, jMinBox.z)
				leftBBox[1].x = math32.Max(leftBBox[1].x, jMaxBox.x)
				leftBBox[1].y = math32.Max(leftBBox[1].y, jMaxBox.y)
				leftBBox[1].z = math32.Max(leftBBox[1].z, jMaxBox.z)
			}

			for j := i; j < len(triangles); j++ {
				jMinBox, jMaxBox := triangles[j].CalculateBoundingBox()
				rightBBox[0].x = math32.Min(rightBBox[0].x, jMinBox.x)
				rightBBox[0].y = math32.Min(rightBBox[0].y, jMinBox.y)
				rightBBox[0].z = math32.Min(rightBBox[0].z, jMinBox.z)
				rightBBox[1].x = math32.Max(rightBBox[1].x, jMaxBox.x)
				rightBBox[1].y = math32.Max(rightBBox[1].y, jMaxBox.y)
				rightBBox[1].z = math32.Max(rightBBox[1].z, jMaxBox.z)
			}

			// Calculate the SAH cost for this split
			cost := float32(i)*calculateSurfaceArea(leftBBox) + float32(len(triangles)-i)*calculateSurfaceArea(rightBBox)
			if cost < bestCost {
				bestCost = cost
				bestSplit = i
				bestAxis = axis
			}
		}
	}

	// Sort triangles along the best axis before splitting
	switch bestAxis {
	case 0:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			return iMinBox.x < jMinBox.x
			// return triangles[i].BoundingBox[0].x < triangles[j].BoundingBox[0].x
		})
	case 1:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].y < triangles[j].BoundingBox[0].y
			return iMinBox.y < jMinBox.y
		})
	case 2:
		sort.Slice(triangles, func(i, j int) bool {
			jMinBox, _ := triangles[j].CalculateBoundingBox()
			iMinBox, _ := triangles[i].CalculateBoundingBox()
			// return triangles[i].BoundingBox[0].z < triangles[j].BoundingBox[0].z
			return iMinBox.z < jMinBox.z
		})
	}

	// Create the BVH node with the best split
	node := &BVHNode{BoundingBox: boundingBox}
	node.Left = buildBVHNode(triangles[:bestSplit], depth+1, maxDepth)
	node.Right = buildBVHNode(triangles[bestSplit:], depth+1, maxDepth)

	return node
}

func (object *object) Move(v Vector) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Add(v)
		object.triangles[i].v2 = object.triangles[i].v2.Add(v)
		object.triangles[i].v3 = object.triangles[i].v3.Add(v)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Rotate(xAngle float32, yAngle float32, zAngle float32) {
	for i := range object.triangles {
		object.triangles[i].Rotate(xAngle, yAngle, zAngle)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func (object *object) Scale(scalar float32) {
	for i := range object.triangles {
		object.triangles[i].v1 = object.triangles[i].v1.Mul(scalar)
		object.triangles[i].v2 = object.triangles[i].v2.Mul(scalar)
		object.triangles[i].v3 = object.triangles[i].v3.Mul(scalar)
		object.triangles[i].CalculateBoundingBox()
	}
	object.CalculateBoundingBox()
}

func CreateObject(triangles []TriangleSimple) *object {
	object := &object{
		triangles: triangles,
		BoundingBox: [2]Vector{
			{math32.MaxFloat32, math32.MaxFloat32, math32.MaxFloat32},
			{-math32.MaxFloat32, -math32.MaxFloat32, -math32.MaxFloat32},
		},
	}
	object.CalculateBoundingBox()
	return object
}

func (object *object) CalculateNormals() {
	for i := range object.triangles {
		object.triangles[i].CalculateNormal()
	}
}

func (object *object) CalculateBoundingBox() {
	for _, triangle := range object.triangles {
		// Update minimum coordinates (BoundingBox[0])
		minBox, maxBox := triangle.CalculateBoundingBox()
		object.BoundingBox[0].x = math32.Min(object.BoundingBox[0].x, minBox.x)
		object.BoundingBox[0].y = math32.Min(object.BoundingBox[0].y, minBox.y)
		object.BoundingBox[0].z = math32.Min(object.BoundingBox[0].z, minBox.z)

		// Update maximum coordinates (BoundingBox[1])
		object.BoundingBox[1].x = math32.Max(object.BoundingBox[1].x, maxBox.x)
		object.BoundingBox[1].y = math32.Max(object.BoundingBox[1].y, maxBox.y)
		object.BoundingBox[1].z = math32.Max(object.BoundingBox[1].z, maxBox.z)
	}
}

func GenerateRandomSpheres(numSpheres int) []object {
	spheres := make([]object, numSpheres)
	for i := 0; i < numSpheres; i++ {
		radius := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		specular := rand.Float32()
		sphere := CreateSphere(position, radius, color, reflection, specular)
		spheres[i] = *CreateObject(sphere)
	}
	return spheres
}

func GenerateRandomCubes(numCubes int) []object {
	cubes := make([]object, numCubes)
	for i := 0; i < numCubes; i++ {
		size := rand.Float32()*50 + 10
		color := ColorFloat32{float32(rand.Intn(255)), float32(rand.Intn(255)), float32(rand.Intn(255)), 255}
		reflection := rand.Float32()
		specular := rand.Float32()
		position := Vector{rand.Float32()*400 - 200, rand.Float32()*400 - 200, rand.Float32()*400 - 200}
		cube := CreateCube(position, size, color, reflection, specular)
		obj := CreateObject(cube)
		obj.Rotate(rand.Float32()*math.Pi, rand.Float32()*math.Pi, rand.Float32()*math.Pi)
		cubes[i] = *obj
	}
	return cubes
}

func (object *object) IntersectBoundingBox(ray Ray) bool {
	tMin := (object.BoundingBox[0].x - ray.origin.x) / ray.direction.x
	tMax := (object.BoundingBox[1].x - ray.origin.x) / ray.direction.x

	if tMin > tMax {
		tMin, tMax = tMax, tMin
	}

	tYMin := (object.BoundingBox[0].y - ray.origin.y) / ray.direction.y
	tYMax := (object.BoundingBox[1].y - ray.origin.y) / ray.direction.y

	if tYMin > tYMax {
		tYMin, tYMax = tYMax, tYMin
	}

	if tMin > tYMax || tYMin > tMax {
		return false
	}

	if tYMin > tMin {
		tMin = tYMin
	}

	if tYMax < tMax {
		tMax = tYMax
	}

	tZMin := (object.BoundingBox[0].z - ray.origin.z) / ray.direction.z
	tZMax := (object.BoundingBox[1].z - ray.origin.z) / ray.direction.z

	if tZMin > tZMax {
		tZMin, tZMax = tZMax, tZMin
	}

	if tMin > tZMax || tZMin > tMax {
		return false
	}

	if tZMin > tMin {
		tMin = tZMin
	}

	if tZMax < tMax {
		tMax = tZMax
	}

	return tMin < math32.Inf(1) && tMax > 0
}

func (object *object) ConvertToTriangles() []TriangleSimple {
	triangles := []TriangleSimple{}
	triangles = append(triangles, object.triangles...)
	return triangles
}

// PositionOnSphere calculates the 3D position on a unit sphere given two angles.
func PositionOnSphere(theta, phi float32) Vector {
	x := math32.Sin(phi) * math32.Cos(theta)
	y := math32.Sin(phi) * math32.Sin(theta)
	z := math32.Cos(phi)
	return Vector{x: x, y: y, z: z}
}

const FOVRadians = FOV * math32.Pi / 180

func PrecomputeScreenSpaceCoordinatesSphere(camera Camera) {
	// Calculate corners
	topLeft := PositionOnSphere(camera.xAxis, camera.yAxis)
	topRight := PositionOnSphere(camera.xAxis+FOVRadians, camera.yAxis)
	bottomLeft := PositionOnSphere(camera.xAxis, camera.yAxis+FOVRadians)

	// Calculate steps
	xStep := Vector{
		x: (topRight.x - topLeft.x) / float32(screenWidth-1),
		y: (topRight.y - topLeft.y) / float32(screenWidth-1),
		z: (topRight.z - topLeft.z) / float32(screenWidth-1),
	}
	yStep := Vector{
		x: (bottomLeft.x - topLeft.x) / float32(screenHeight-1),
		y: (bottomLeft.y - topLeft.y) / float32(screenHeight-1),
		z: (bottomLeft.z - topLeft.z) / float32(screenHeight-1),
	}

	// Interpolate
	for width := 0; width < screenWidth; width++ {
		for height := 0; height < screenHeight; height++ {
			ScreenSpaceCoordinates[width][height] = Vector{
				x: topLeft.x + float32(width)*xStep.x + float32(height)*yStep.x,
				y: topLeft.y + float32(width)*xStep.y + float32(height)*yStep.y,
				z: topLeft.z + float32(width)*xStep.z + float32(height)*yStep.z,
			}
		}
	}
}

func DrawRays(camera Camera, light Light, scaling int, samples int, depth int, subImages []*ebiten.Image) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					c := TraceRay(Ray{origin: camera.Position, direction: rayDir}, depth, light, samples)

					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = clampUint8(c.R)
					pixelBuffer[index+1] = clampUint8(c.G)
					pixelBuffer[index+2] = clampUint8(c.B)
					pixelBuffer[index+3] = clampUint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

func DrawSpheres(camera Camera, scaling int, iterations int, subImages []*ebiten.Image, light Light) {
	var wg sync.WaitGroup

	// Create a pool of worker goroutines, each handling a portion of the image
	for i := 0; i < numCPU; i++ {
		wg.Add(1)
		go func(startY int, endIndex int, subImage *ebiten.Image) {
			defer wg.Done()
			yRow := 0
			width, height := subImage.Bounds().Dx(), subImage.Bounds().Dy()
			imageSize := width * height * 4
			pixelBuffer := make([]uint8, imageSize)
			for y := startY; y < endIndex; y += scaling {
				xColumn := 0
				for x := 0; x < screenWidth; x += scaling {
					rayDir := ScreenSpaceCoordinates[x][y]
					// c, _ := RayMarching(Ray{origin: camera.Position, direction: rayDir}, spheres, iterations, light)
					c, _ := RayMarchBvh(Ray{origin: camera.Position, direction: rayDir}, iterations, light)
					// Write the pixel color to the pixel buffer
					index := ((yRow*width + xColumn) * 4)
					pixelBuffer[index] = uint8(c.R)
					pixelBuffer[index+1] = uint8(c.G)
					pixelBuffer[index+2] = uint8(c.B)
					pixelBuffer[index+3] = uint8(c.A)
					xColumn++
					// // Set the pixel color in the sub-image
					// subImage.Set(x/scaling, yRow, c)
				}
				yRow++
			}
			subImage.WritePixels(pixelBuffer)
		}(i*rowSize, (i+1)*rowSize, subImages[i])
	}
	// Wait for all workers to finish
	wg.Wait()
}

var (
	bgColor        = color.RGBA{50, 50, 50, 255}
	trackColor     = color.RGBA{200, 200, 200, 255}
	colorSliderInd = color.RGBA{255, 0, 0, 255}
	propSliderInd  = color.RGBA{0, 255, 255, 255}
	selectedColor  = color.RGBA{255, 0, 0, 255}

	bgUniform       = &image.Uniform{bgColor}
	trackUniform    = &image.Uniform{trackColor}
	colorSliderUnif = &image.Uniform{colorSliderInd}
	propSliderUnif  = &image.Uniform{propSliderInd}

	selectedOptionUniform = &image.Uniform{selectedColor}

	optionUniform = &image.Uniform{color.RGBA{100, 100, 100, 255}}
)

type Options struct {
	Header               string
	Options              []string
	Selected             int
	Width                int
	Height               int
	Padding              int
	PositionX, PositionY int
}



func SelectOption(opts *Options, screen *ebiten.Image, mouseX, mouseY int, mousePressed bool) {
	mouseX -= opts.Width

	// Draw background
	bgRect := image.Rect(opts.PositionX, opts.PositionY, opts.PositionX+opts.Width, opts.PositionY+opts.Height)
	draw.Draw(screen, bgRect, bgUniform, image.Point{}, draw.Src)

	// Calculate button size
	numButtons := len(opts.Options)
	buttonWidth := (opts.Width / numButtons) - opts.Padding
	buttonHeight := opts.Height - 2*opts.Padding

	// Draw buttons
	for i := 0; i < numButtons; i++ {
		buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
		buttonY := opts.PositionY + opts.Padding
		buttonRect := image.Rect(buttonX, buttonY, buttonX+buttonWidth, buttonY+buttonHeight)

		// Draw selected or unselected button
		if i == opts.Selected {
			draw.Draw(screen, buttonRect, selectedOptionUniform, image.Point{}, draw.Src)
		} else {
			draw.Draw(screen, buttonRect, optionUniform, image.Point{}, draw.Src)
		}

		// Display option text
		ebitenutil.DebugPrintAt(screen, opts.Options[i], buttonX+5, buttonY+5)
	}

	// Handle mouse interaction
	if mousePressed {
		for i := 0; i < numButtons; i++ {
			buttonX := opts.PositionX + i*(buttonWidth+opts.Padding)
			buttonY := opts.PositionY + opts.Padding
			if mouseX > buttonX && mouseX < buttonX+buttonWidth && mouseY > buttonY && mouseY < buttonY+buttonHeight {
				opts.Selected = i
				break
			}
		}
	}

	// Draw header text
	ebitenutil.DebugPrintAt(screen, opts.Header, opts.PositionX, opts.PositionY+10)
}

type SliderLayout struct {
	sliderWidth     int
	sliderHeight    int
	indicatorHeight int
	padding         int
	startX          int
	startY          int
}

// ColorSlider handles color, reflection and specular value adjustments
func ColorSlider(x, y int, screen *ebiten.Image, width, height int, r, g, b, a *float64,
	reflection, specular *float32, mouseX, mouseY int, mousePressed bool, directToScatter *float32, m *float32) {

	// Calculate layout once
	layout := SliderLayout{
		sliderWidth:     width - 20,
		sliderHeight:    15,
		indicatorHeight: 12,
		padding:         5,
		startX:          x + 10,
		startY:          y + height/3 + 10,
	}

	// Draw background (single allocation)
	draw.Draw(screen, image.Rect(x, y, x+width, y+height), bgUniform, image.Point{}, draw.Src)

	// Draw preview area
	previewColor := &image.Uniform{color.RGBA{
		uint8(*r * 255),
		uint8(*g * 255),
		uint8(*b * 255),
		uint8(*a * 255),
	}}
	draw.Draw(screen, image.Rect(x, y, x+width, y+height/3), previewColor, image.Point{}, draw.Src)

	// Process sliders
	processSlider(screen, layout, ""R"", r, false, 0, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""G"", g, false, 1, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""B"", b, false, 2, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""A"", a, false, 3, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Light Intensity"", m, true, 4, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Reflection"", reflection, true, 5, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Specular"", specular, true, 6, mouseX, mouseY, mousePressed)
	processSlider(screen, layout, ""Direct To Scatter"", directToScatter, true, 7, mouseX, mouseY, mousePressed)
}

func processSlider(screen *ebiten.Image, layout SliderLayout, label string, value interface{},
	isFloat32 bool, index int, mouseX, mouseY int, mousePressed bool) {

	// Calculate positions
	yOffset := layout.startY + (layout.sliderHeight+layout.padding)*index
	trackRect := image.Rect(
		layout.startX,
		yOffset,
		layout.startX+layout.sliderWidth,
		yOffset+layout.sliderHeight,
	)

	// Draw track
	draw.Draw(screen, trackRect, trackUniform, image.Point{}, draw.Src)

	// Get current value
	var currentValue float64
	if isFloat32 {
		currentValue = float64(*value.(*float32))
	} else {
		currentValue = *value.(*float64)
	}

	// Calculate and draw indicator
	valueX := int(currentValue*float64(layout.sliderWidth)) + layout.startX
	indicatorRect := image.Rect(
		valueX-5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2,
		valueX+5,
		yOffset+(layout.sliderHeight-layout.indicatorHeight)/2+layout.indicatorHeight,
	)

	// Draw indicator with appropriate color
	if isFloat32 {
		draw.Draw(screen, indicatorRect, propSliderUnif, image.Point{}, draw.Src)
	} else {
		draw.Draw(screen, indicatorRect, colorSliderUnif, image.Point{}, draw.Src)
	}

	// Draw label
	ebitenutil.DebugPrintAt(screen, label, layout.startX, yOffset+5)

	// Handle mouse interaction
	if mousePressed && trackRect.Overlaps(image.Rect(mouseX, mouseY, mouseX+1, mouseY+1)) {
		newValue := clamp(float64(mouseX-layout.startX) / float64(layout.sliderWidth))
		if isFloat32 {
			*value.(*float32) = float32(newValue)
		} else {
			*value.(*float64) = newValue
		}
	}
}

// clamp ensures a value stays between 0 and 1
func clamp(value float64) float64 {
	if value < 0 {
		return 0
	}
	if value > 1 {
		return 1
	}
	return value
}

func findIntersectionAndSetColor(node *BVHNode, ray Ray, newColor ColorFloat32, reflection float32, specular float32, directToScatter float32, multiplayer float32) bool {
	if node == nil {
		return false
	}

	// Check if ray intersects the bounding box of the node
	if !BoundingBoxCollision(node.BoundingBox, &ray) {
		return false
	}

	// If this is a leaf node, check the triangles for intersection
	if node.active {
		// for i, triangle := range *node.Triangles {
		if _, hit := ray.IntersectTriangleSimple(node.Triangles); hit {
			// fmt.Println(""Triangle hit"", triangle.color)
			m := float32(1)
			if multiplayer > 0.05 {
				m = (multiplayer + 1)
			}

			c := ColorFloat32{
				R: newColor.R * (m * m * m),
				G: newColor.G * (m * m * m),
				B: newColor.B * (m * m * m),
				A: newColor.A,
			}
			NewTriangle := TriangleSimple{
				v1:              node.Triangles.v1,
				v2:              node.Triangles.v2,
				v3:              node.Triangles.v3,
				color:           c,
				Normal:          node.Triangles.Normal,
				reflection:      reflection,
				specular:        specular,
				directToScatter: directToScatter,
			}
			node.Triangles = NewTriangle
			return true
		}
		// }
		return false
	}

	// Traverse the left and right child nodes
	leftHit := findIntersectionAndSetColor(node.Left, ray, newColor, reflection, specular, directToScatter, multiplayer)
	rightHit := findIntersectionAndSetColor(node.Right, ray, newColor, reflection, specular, directToScatter, multiplayer)

	return leftHit || rightHit
}

const sensitivityX = 0.005
const sensitivityY = 0.005

func calculateMin15PercentFPS() float64 {
	sort.Float64s(FPS)
	tenPercentCount := int(0.15 * float64(len(FPS)))

	if tenPercentCount == 0 {
		return FPS[0] // Handle case with fewer than 10 samples
	}

	min10PercentValues := FPS[:tenPercentCount]
	sum := 0.0
	for _, fps := range min10PercentValues {
		sum += fps
	}
	averageMin10PercentFPS := sum / float64(tenPercentCount)
	fmt.Printf(""Calculated average FPS of lowest 15%%: %.2f\n"", averageMin10PercentFPS)
	return averageMin10PercentFPS
}

func writeCSV(filename string, data [][]string) error {
	fmt.Printf(""Writing data to %s...\n"", filename)

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		if err := writer.Write(record); err != nil {
			return err
		}
	}

	fmt.Println(""Benchmark data saved successfully."")
	return nil
}

func dumpBenchmarkData() error {
	const csvFileName = ""benchmark_results.csv""

	fmt.Println(""Starting benchmark data dump..."")

	// Read the main.go code
	code, err := os.ReadFile(""main.go"")
	if err != nil {
		return err
	}
	codeString := string(code)

	// Calculate average FPS for this run
	currentAvgFPS := AverageFrameRate / float64(FrameCount)
	min10PercentFPS := calculateMin15PercentFPS() // Calculate min 15% FPS
	fmt.Printf(""Current run - Average FPS: %.2f, Min FPS: %.2f, Max FPS: %.2f, Min 15%% FPS: %.2f\n"", currentAvgFPS, MinFrameRate, MaxFrameRate, min10PercentFPS)

	// Check if CSV file exists and read existing data
	var records [][]string
	file, err := os.OpenFile(csvFileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Println(""Reading existing benchmark results..."")
	reader := csv.NewReader(file)
	records, _ = reader.ReadAll()

	// Check if the code already exists in the CSV
	for i, record := range records {
		if len(record) > 0 && record[0] == codeString {
			fmt.Println(""Code already exists in CSV. Updating averages..."")

			// Parse existing FPS and framerate values
			existingFPS, err := strconv.ParseFloat(record[1], 64)
			if err != nil {
				return err
			}
			existingMinFPS, err := strconv.ParseFloat(record[2], 64)
			if err != nil {
				return err
			}
			existingMaxFPS, err := strconv.ParseFloat(record[3], 64)
			if err != nil {
				return err
			}
			existingMin10PercentFPS, err := strconv.ParseFloat(record[4], 64)
			if err != nil {
				return err
			}

			// Calculate new averages
			newAvgFPS := (existingFPS + currentAvgFPS) / 2
			newMinFPS := (existingMinFPS + MinFrameRate) / 2
			newMaxFPS := (existingMaxFPS + MaxFrameRate) / 2
			newMin10PercentFPS := (existingMin10PercentFPS + min10PercentFPS) / 2

			fmt.Printf(""Old FPS: %.2f, New FPS: %.2f, Updated Average FPS: %.2f\n"", existingFPS, currentAvgFPS, newAvgFPS)
			fmt.Printf(""Old Min FPS: %.2f, New Min FPS: %.2f\n"", existingMinFPS, newMinFPS)
			fmt.Printf(""Old Max FPS: %.2f, New Max FPS: %.2f\n"", existingMaxFPS, newMaxFPS)
			fmt.Printf(""Old Min 15%% FPS: %.2f, New Min 15%% FPS: %.2f\n"", existingMin10PercentFPS, newMin10PercentFPS)

			// Update the record with new averages
			records[i][1] = fmt.Sprintf(""%.2f"", newAvgFPS)
			records[i][2] = fmt.Sprintf(""%.2f"", newMinFPS)
			records[i][3] = fmt.Sprintf(""%.2f"", newMaxFPS)
			records[i][4] = fmt.Sprintf(""%.2f"", newMin10PercentFPS)

			// Write updated data back to CSV
			return writeCSV(csvFileName, records)
		}
	}

	// If code is not found, add a new row
	fmt.Println(""Code not found in CSV. Adding new entry."")
	newRecord := []string{
		codeString,
		fmt.Sprintf(""%.2f"", currentAvgFPS),   // Average FPS
		fmt.Sprintf(""%.2f"", MinFrameRate),    // Min FPS
		fmt.Sprintf(""%.2f"", MaxFrameRate),    // Max FPS
		fmt.Sprintf(""%.2f"", min10PercentFPS), // Min 15% FPS
	}
	records = append(records, newRecord)

	// Write data back to CSV
	return writeCSV(csvFileName, records)
}

func (g *Game) Update() error {

	if Benchmark {
		// rotate the camera around the y-axis
		g.camera.yAxis += 0.005
		PrecomputeScreenSpaceCoordinatesSphere(g.camera)

		// Move the light source
		g.light.Position.x += 0.005

		// Move Camera
		g.camera.Position.x += 0.01
		g.camera.Position.y += 0.01

		if time.Since(startTime) > time.Second*40 {
			// Dump code and FPS to CSV
			if err := dumpBenchmarkData(); err != nil {
				fmt.Println(""Error dumping benchmark data:"", err)
			}
			os.Exit(0)
		}
	} else {

		if snapLightToCamera.Selected == 1 {
			g.light.Position = &g.camera.Position
		}

		mouseX, mouseY := ebiten.CursorPosition()
		if fullScreen {
			// Get the current mouse position
			dx := float32(mouseX-g.cursorX) * sensitivityX
			g.camera.xAxis += float32(dx)
			g.cursorX = mouseX

			dy := float32(mouseY-g.cursorY) * sensitivityY
			g.camera.yAxis += dy
			g.cursorY = mouseY

			forward := Vector{1, 0, 0}
			right := Vector{0, 1, 0}
			up := Vector{0, 0, 1}

			if ebiten.IsKeyPressed(ebiten.KeyShiftLeft) {
				g.xyzLock = !g.xyzLock
			}

			if g.xyzLock {
				forward = ScreenSpaceCoordinates[screenHeight/2][screenWidth/2]
				forward = Vector{forward.x, forward.y, 0}.Normalize()
				right = forward.Cross(Vector{0, 1, 0})
				up = right.Cross(forward)
			}
			speed := float32(5)

			if ebiten.IsKeyPressed(ebiten.KeyW) {
				g.camera.Position = g.camera.Position.Add(forward.Mul(speed)) // Move forward
			}
			if ebiten.IsKeyPressed(ebiten.KeyS) {
				g.camera.Position = g.camera.Position.Sub(forward.Mul(speed)) // Move backward
			}
			if ebiten.IsKeyPressed(ebiten.KeyD) {
				g.camera.Position = g.camera.Position.Add(right.Mul(speed)) // Move right
			}
			if ebiten.IsKeyPressed(ebiten.KeyA) {
				g.camera.Position = g.camera.Position.Sub(right.Mul(speed)) // Move left
			}
			if ebiten.IsKeyPressed(ebiten.KeyE) {
				g.camera.Position = g.camera.Position.Add(up.Mul(speed)) // Move up
			}
			if ebiten.IsKeyPressed(ebiten.KeyQ) {
				g.camera.Position = g.camera.Position.Sub(up.Mul(speed)) // Move down
			}

			PrecomputeScreenSpaceCoordinatesSphere(g.camera)
		} else {
			if ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft) && mouseX >= 0 && mouseY >= 0 && mouseX < screenWidth/2 && mouseY < screenHeight/2 {
				findIntersectionAndSetColor(BVH, Ray{origin: g.camera.Position, direction: ScreenSpaceCoordinates[mouseX*2][mouseY*2]}, ColorFloat32{float32(g.r * 255), float32(g.g * 255), float32(g.b * 255), float32(g.a * 255)}, g.reflection, g.specular, g.directToScatter, g.ColorMultiplier)
			}
		}

		// check if mouse button is pressed

		if ebiten.IsKeyPressed(ebiten.KeyTab) {
			fullScreen = !fullScreen
		}

	}
	return nil
}

// func saveEbitenImageAsPNG(ebitenImg *ebiten.Image, filename string) error {
// 	// Get the size of the Ebiten image
// 	width, height := ebitenImg.Size()

// 	// Create an RGBA image to hold the pixel data
// 	rgba := image.NewRGBA(image.Rect(0, 0, width, height))

// 	// Iterate over the pixels in the Ebiten image and copy them to the RGBA image
// 	for y := 0; y < height; y++ {
// 		for x := 0; x < width; x++ {
// 			c := ebitenImg.At(x, y).(color.RGBA)
// 			rgba.Set(x, y, c)
// 		}
// 	}

// 	// Create the output file
// 	outFile, err := os.Create(filename)
// 	if err != nil {
// 		return err
// 	}
// 	defer outFile.Close()

// 	// Encode the RGBA image as a PNG and save it
// 	err = png.Encode(outFile, rgba)
// 	if err != nil {
// 		return err
// 	}

// 	return nil
// }

var (
	GUI              = ebiten.NewImage(400, 600)
	lastMousePressed bool
	guiNeedsUpdate   = true // Start with true to ensure initial render
	depthOption      = Options{
		Header:    ""Select Depth"",
		Options:   []string{""1"", ""2"", ""4"", ""8"", ""16"", ""32""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 0,
	}
	scatterOption = Options{
		Header:    ""Select Scatter"",
		Options:   []string{""0"", ""1"", ""2"", ""4"", ""8"", ""16"", ""32"", ""64""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 350,
	}
	snapLightToCamera = Options{
		Header:    ""Snap Light to Camera"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 400,
	}
	screenResolution = Options{
		Header:    ""Render Resolution"",
		Options:   []string{""Native"", ""2X"", ""4X"", ""8X""},
		Selected:  1,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 450,
	}

	rayMarching = Options{
		Header:    ""Ray Marching"",
		Options:   []string{""No"", ""Yes""},
		Selected:  0,
		Width:     400,
		Height:    50,
		Padding:   10,
		PositionX: 0,
		PositionY: 500,
	}
)

func (g *Game) Draw(screen *ebiten.Image) {
	// Increment frame count and add current FPS to the average
	if Benchmark {
		FrameCount++
		fps := ebiten.ActualFPS()
		AverageFrameRate += fps

		MinFrameRate = math.Min(MinFrameRate, fps)
		MaxFrameRate = math.Max(MaxFrameRate, fps)

		FPS = append(FPS, fps)
	}

	/// Clear the current frame
	g.currentFrame.Clear()
	fps := ebiten.ActualFPS()

	// Perform path tracing and draw rays into the current frame

	depth := 2
	if !Benchmark {
		depth = depthOption.Selected
		depth = depth*2 + 1
	}

	scatter := 0
	if !Benchmark {
		scatter = scatterOption.Selected
		if scatter > 1 {
			scatter *= 2
		}
	}

	DrawRays(g.camera, g.light, g.scaleFactor, scatter, depth, g.subImages)
	for i, subImage := range g.subImages {
		op := &ebiten.DrawImageOptions{}
		// if !fullScreen {
		op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
		// } else {
		// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
		// }
		g.currentFrame.DrawImage(subImage, op)
	}

	if !Benchmark && rayMarching.Selected == 1 {
		DrawSpheres(g.camera, g.scaleFactor, 32, g.subImages, g.light)
		for i, subImage := range g.subImages {
			op := &ebiten.DrawImageOptions{}
			// if !fullScreen {
			op.GeoM.Translate(0, float64(subImageHeight/screenResolution.Selected)*float64(i))
			// } else {
			// 	op.GeoM.Translate(0, float64(subImageHeight)*float64(i))
			// }
			g.currentFrame.DrawImage(subImage, op)
		}
	}

	// Scale the main render
	mainOp := &ebiten.DrawImageOptions{}

	if !fullScreen {
		mainOp.GeoM.Scale(
			float64(screenResolution.Selected),
			float64(screenResolution.Selected),
		)
	} else {
		mainOp.GeoM.Scale(
			float64(g.scaleFactor),
			float64(g.scaleFactor),
		)
	}

	// Draw the main render first
	screen.DrawImage(g.currentFrame, mainOp)

	// Handle GUI separately
	if !fullScreen {
		mouseX, mouseY := ebiten.CursorPosition()
		mousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)

		// Check if GUI needs updating
		if mousePressed || lastMousePressed != mousePressed {
			guiNeedsUpdate = true
		}

		// Only update GUI if needed
		if guiNeedsUpdate {
			GUI.Clear()
			ColorSlider(0, 50, GUI, 400, 200, &g.r, &g.g, &g.b, &g.a, &g.reflection, &g.specular, mouseX-400, mouseY, mousePressed, &g.directToScatter, &g.ColorMultiplier)
			SelectOption(&depthOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&scatterOption, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&snapLightToCamera, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&screenResolution, GUI, mouseX, mouseY, mousePressed)
			SelectOption(&rayMarching, GUI, mouseX, mouseY, mousePressed)
			guiNeedsUpdate = false
			if screenResolution.Selected == 0 {
				g.scaleFactor = 1
			}
			g.scaleFactor = screenResolution.Selected * 2
		}
		lastMousePressed = mousePressed

		// Draw GUI on top of the main render
		guiOp := &ebiten.DrawImageOptions{}
		guiOp.GeoM.Translate(400, 0)
		screen.DrawImage(GUI, guiOp)

		lastMousePressed = mousePressed
	}

	// rayMarchingOpts := &ebiten.DrawRectShaderOptions{}
	// rayMarchingOpts.Images[0] = g.currentFrame
	// rayMarchingOpts.Uniforms = map[string]interface{}{
	// 	""StartPosition"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""TopLeft"":     []float32{ScreenSpaceCoordinates[0][0].x, ScreenSpaceCoordinates[0][0].y, ScreenSpaceCoordinates[0][0].z},
	// 	""TopRight"":   []float32{ScreenSpaceCoordinates[screenWidth-1][0].x, ScreenSpaceCoordinates[screenWidth-1][0].y, ScreenSpaceCoordinates[screenWidth-1][0].z},
	// 	""BottomLeft"":  []float32{ScreenSpaceCoordinates[0][screenHeight-1].x, ScreenSpaceCoordinates[0][screenHeight-1].y, ScreenSpaceCoordinates[0][screenHeight-1].z},
	// }

	// // Apply the ray marching shader
	// rayMarchingImage.DrawRectShader(
	// 	rayMarchingImage.Bounds().Dx(),
	// 	rayMarchingImage.Bounds().Dy(),
	// 	g.RayMarchShader,
	// 	rayMarchingOpts,
	// )

	// // Draw the ray marching image to the screen
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(rayMarchingImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(rayMarchingImage.Bounds().Dy()))
	// screen.DrawImage(rayMarchingImage, op1)

	// Create a temporary image for bloom shader
	// bloomImage := ebiten.NewImageFromImage(g.currentFrame)

	// Apply Bloom shader
	// bloomOpts := &ebiten.DrawRectShaderOptions{}
	// bloomOpts.Images[0] = g.currentFrame
	// bloomOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":     []float32{float32(bloomImage.Bounds().Dx()), float32(bloomImage.Bounds().Dy())},
	// 	""bloomThreshold"": 1,
	// }

	// // Apply the bloom shader
	// bloomImage.DrawRectShader(
	// 	bloomImage.Bounds().Dx(),
	// 	bloomImage.Bounds().Dy(),
	// 	g.bloomShader,
	// 	bloomOpts,
	// )

	// Apply Dither shader
	// ditherImage := ebiten.NewImageFromImage(bloomImage)
	// ditherOpts := &ebiten.DrawRectShaderOptions{}
	// ditherOpts.Images[0] = g.currentFrame
	// ditherOpts.Uniforms = map[string]interface{}{
	// 	""screenSize"":  []float32{float32(ditherImage.Bounds().Dx()), float32(ditherImage.Bounds().Dy())},
	// 	""BayerMatrix"": bayerMatrix,
	// }

	// // Apply the dither shader
	// ditherImage.DrawRectShader(
	// 	ditherImage.Bounds().Dx(),
	// 	ditherImage.Bounds().Dy(),
	// 	g.ditherColor,
	// 	ditherOpts,
	// )

	// Draw the current frame (bloomImage) to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// Draw bloomImage to the screen, scaling it to screen size
	// op1 := &ebiten.DrawImageOptions{}
	// op1.GeoM.Scale(float64(screen.Bounds().Dx())/float64(bloomImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(bloomImage.Bounds().Dy()))
	// screen.DrawImage(bloomImage, op1)

	// Create Triangle Rendering Shader
	// triangleImage := ebiten.NewImageFromImage(ditherImage)
	// triangleOpts := &ebiten.DrawRectShaderOptions{}
	// triangleOpts.Images[0] = ditherImage
	// triangleOpts.Uniforms = map[string]interface{}{
	// 	""cameraPos"": []float32{g.camera.Position.x, g.camera.Position.y, g.camera.Position.z},
	// 	""cameraDir"": []float32{g.camera.xAxis, g.camera.yAxis, g.camera.zAxis},
	// 	""cameraPitch"" : g.camera.xAxis,
	// 	""cameraYaw"" : g.camera.yAxis,
	// 	""cameraRoll"" : g.camera.zAxis,
	// 	""cameraFoe"" : FOV,

	// 	""TriangleV1"": TrianglesV1,
	// 	""TriangleV2"": TrianglesV2,
	// 	""TriangleV3"": TrianglesV3,

	// 	""epsilon"": 0.0001,
	// 	""maxDist "": 1000.0,
	// }

	// // Apply the triangle shader
	// triangleImage.DrawRectShader(
	// 	triangleImage.Bounds().Dx(),
	// 	triangleImage.Bounds().Dy(),
	// 	g.TriangleShader,
	// 	triangleOpts,
	// )

	// screen.DrawImage(triangleImage, op1)
	// // Prepare the options for ditherImage with darker blending
	// op2 := &ebiten.DrawImageOptions{}
	// op2.GeoM.Scale(float64(screen.Bounds().Dx())/float64(ditherImage.Bounds().Dx()),
	// 	float64(screen.Bounds().Dy())/float64(ditherImage.Bounds().Dy()))
	// op2.CompositeMode = ebiten.CompositeModeMultiply // Set to multiply for darker blending

	// // Draw ditherImage with darker blending
	// screen.DrawImage(ditherImage, op2)

	// Show the current FPS
	ebitenutil.DebugPrint(screen, fmt.Sprintf(""FPS: %.2f"", fps))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 800, 608
}

var BVH *BVHNode
var FrameCount int

type Game struct {
	xyzLock          bool
	cursorX, cursorY int
	subImages        []*ebiten.Image
	camera           Camera
	light            Light
	scaleFactor      int
	currentFrame     *ebiten.Image
	// ditherColor      *ebiten.Shader
	// ditherGrayScale  *ebiten.Shader
	// bloomShader      *ebiten.Shader
	// contrastShader   *ebiten.Shader
	// tintShader       *ebiten.Shader
	// sharpnessShader  *ebiten.Shader
	r, g, b, a      float64
	specular        float32
	reflection      float32
	previousFrame   *ebiten.Image
	directToScatter float32
	ColorMultiplier float32
	// RayMarchShader  *ebiten.Shader
	// TriangleShader         *ebiten.Shader
}

// LoadShader reads a shader file from the provided path and returns its content as a byte slice.
func LoadShader(filePath string) ([]byte, error) {
	// Read the entire file into memory
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	return data, nil
}

// Bayer matrix data
// var bayerMatrix = [16]float32{
// 	15.0 / 255.0, 195.0 / 255.0, 60.0 / 255.0, 240.0 / 255.0,
// 	135.0 / 255.0, 75.0 / 255.0, 180.0 / 255.0, 120.0 / 255.0,
// 	45.0 / 255.0, 225.0 / 255.0, 30.0 / 255.0, 210.0 / 255.0,
// 	165.0 / 255.0, 105.0 / 255.0, 150.0 / 255.0, 90.0 / 255.0,
// }

const subImageHeight = screenHeight / numCPU / 2
const subImageWidth = screenWidth

var fullScreen = false
var startTime time.Time

var Spheres = []SphereSimple{}

func main() {
	// src, err := LoadShader(""shaders/ditherColor.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// ditherShaderColor, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/ditherGray.kage"")
	// if err != nil {RotationMatrix
	// ditherGrayShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	// src, err = LoadShader(""shaders/RayCaster.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// rayCasterShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }
	// fmt.Println(""Shader:"", rayCasterShader)

	// src, err = LoadShader(""shaders/bloom.kage"")
	// if err != nil {
	// 	panic(err)
	// }
	// bloomShader, err := ebiten.NewShader(src)
	// if err != nil {
	// 	panic(err)
	// }

	src, err := LoadShader(""shaders/contrast.kage"")
	if err != nil {
		panic(err)
	}
	contrastShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", contrastShader)

	src, err = LoadShader(""shaders/tint.kage"")
	if err != nil {
		panic(err)
	}
	tintShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", tintShader)

	src, err = LoadShader(""shaders/sharpness.kage"")
	if err != nil {
		panic(err)
	}
	sharpnessShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	src, err = LoadShader(""shaders/rayMarching.kage"")
	if err != nil {
		panic(err)
	}

	rayMarchingShader, err := ebiten.NewShader(src)
	if err != nil {
		panic(err)
	}

	fmt.Println(""Shader:"", rayMarchingShader)

	fmt.Println(""Shader:"", sharpnessShader)
	// fmt.Println(""Shader:"", bloomShader)
	// fmt.Println(""Shader:"", ditherGrayShader)

	fmt.Println(""Number of CPUs:"", numCPU)

	runtime.GOMAXPROCS(numCPU)

	ebiten.SetVsyncEnabled(false)
	ebiten.SetTPS(24)

	// spheres := GenerateRandomSpheres(15)
	// cubes := GenerateRandomCubes(30)

	obj := object{}
	if Benchmark {
		fullScreen = true
		obj, err = LoadOBJ(""Room.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	} else {
		obj, err = LoadOBJ(""monkey.obj"")
		if err != nil {
			panic(err)
		}
		obj.Scale(75)
	}

	objects := []object{}
	objects = append(objects, obj)

	camera := Camera{Position: Vector{0, 100, 0}, xAxis: 0, yAxis: 0}
	light := Light{Position: &Vector{0, 1500, 1000}, Color: &[3]float32{1, 1, 1}, intensity: 2}

	// bestDepth := OptimizeBVHDepth(objects, camera, light)

	// objects = append(objects, spheres...)
	// objects = append(objects, cubes...)

	BVH = ConvertObjectsToBVH(objects, maxDepth)
	PrecomputeScreenSpaceCoordinatesSphere(camera)
	scale := 2

	subImages := make([]*ebiten.Image, numCPU)

	for i := range numCPU {
		subImages[i] = ebiten.NewImage(int(subImageWidth), int(subImageHeight))
	}

	sphereBVH = *BuildBvhForSpheres(obj.ConvertToSquare(256), 6)

	game := &Game{
		xyzLock:     true,
		cursorX:     screenHeight / 2,
		cursorY:     screenWidth / 2,
		subImages:   subImages,
		camera:      camera,
		light:       light,
		scaleFactor: scale,
		// ditherColor:     ditherShaderColor,
		// ditherGrayScale: ditherGrayShader,
		// bloomShader:     bloomShader,
		currentFrame:  ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		previousFrame: ebiten.NewImage(screenWidth/scale, screenHeight/scale),
		// RayMarchShader: rayMarchingShader,
		// TriangleShader: 	   rayCasterShader,
	}

	startTime = time.Now()

	ebiten.SetWindowSize(screenWidth, screenHeight)
	ebiten.SetWindowTitle(""Ebiten Benchmark"")

	if err := ebiten.RunGame(game); err != nil {
		panic(err)
	}
}
",192.11,0.05,237.53,12.38
