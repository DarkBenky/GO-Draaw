package main

var BloomThreshold float
var BloomIntensity float
var Alpha float


func BoxBlurPass(texCoord vec2, stepSize float) vec4 {
    color := vec4(0)
    weight := 0.0
    
    for x := -2; x <= 2; x += 1 {
        for y := -2; y <= 2; y += 1 {
            offset := vec2(float(x), float(y)) * stepSize / imageSrcTextureSize()
            sampleColor := imageSrc0At(texCoord + offset)
            
            // Distance-based weight
            w := 1.0 - length(vec2(float(x), float(y))) * 0.2
            if w > 0.0 {
                color += sampleColor * w
                weight += w
            }
        }
    }
    
    return color / weight
}

func MultiPassBlur(texCoord vec2) vec4 {
    // Multiple blur passes with increasing radius
    blur1 := BoxBlurPass(texCoord, 1.0)
    blur2 := BoxBlurPass(texCoord, 2.0)
    blur3 := BoxBlurPass(texCoord, 4.0)
    
    // Combine blur passes with different weights
    finalBlur := (blur1 * 0.5) + (blur2 * 0.3) +( blur3 * 0.3)
    
    return finalBlur
}

func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
    originalColor := imageSrc0At(texCoord)

    luminance := originalColor.r * 0.2126 + originalColor.g * 0.7152 + originalColor.b * 0.0722
    if luminance < BloomThreshold {
        return vec4(0.0, 0.0, 0.0, 0.0)
    }
    bloomColor := MultiPassBlur(texCoord)
    // Combine original with bloom
    resultColor := (originalColor + bloomColor) * BloomIntensity

    if resultColor.r > 1.0 {
        resultColor.r = 1.0
    }
    if resultColor.g > 1.0 {
        resultColor.g = 1.0
    }
    if resultColor.b > 1.0 {
        resultColor.b = 1.0
    }

    resultColor.r *= Alpha
    resultColor.g *= Alpha
    resultColor.b *= Alpha
    resultColor.a = Alpha
    
    return resultColor
}