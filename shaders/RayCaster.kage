package main

var (
    TrianglesV1X    [32]float
    TrianglesV1Y    [32]float
    TrianglesV1Z    [32]float
    TrianglesV2X    [32]float
    TrianglesV2Y    [32]float
    TrianglesV2Z    [32]float
    TrianglesV3X    [32]float
    TrianglesV3Y    [32]float
    TrianglesV3Z    [32]float
    TrianglesColorR [32]float
    TrianglesColorG [32]float
    TrianglesColorB [32]float
    CameraPos       vec3
    CameraYaw       float
    CameraPitch     float
    CameraFov       float
)

// Function to calculate ray-triangle intersection
func rayTriangleIntersect(rayOrigin, rayDir vec3, v0x, v0y, v0z, v1x, v1y, v1z, v2x, v2y, v2z float) (float, bool) {
    epsilon := float(0.000001)

    v0Vec := vec3(v0x, v0y, v0z)
    v1Vec := vec3(v1x, v1y, v1z)
    v2Vec := vec3(v2x, v2y, v2z)

    edge1 := v1Vec - v0Vec
    edge2 := v2Vec - v0Vec
    h := cross(rayDir, edge2)
    a := dot(edge1, h)

    if a > -epsilon && a < epsilon {
        return 0.0, false
    }

    f := 1.0 / a
    s := rayOrigin - v0Vec
    u := f * dot(s, h)

    if u < 0.0 || u > 1.0 {
        return 0.0, false
    }

    q := cross(s, edge1)
    v := f * dot(rayDir, q)

    if v < 0.0 || u+v > 1.0 {
        return 0.0, false
    }

    t := f * dot(edge2, q)

    if t > epsilon {
        return t, true
    }

    return 0.0, false
}

// Fragment shader logic
func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
    aspectRatio := imageDstTextureSize().x / imageDstTextureSize().y

    // Calculate ray direction
    x := (2.0*texCoord.x - 1.0) * aspectRatio * tan(CameraFov/2.0)
    y := (1.0 - 2.0*texCoord.y) * tan(CameraFov/2.0)

    // Apply camera rotation
    rayDir := normalize(vec3(
        cos(CameraYaw)*cos(CameraPitch)*x + sin(CameraYaw)*y + cos(CameraYaw)*sin(CameraPitch),
        sin(CameraYaw)*cos(CameraPitch)*x - cos(CameraYaw)*y + sin(CameraYaw)*sin(CameraPitch),
        -sin(CameraPitch)*x + cos(CameraPitch),
    ))

    nearestDist := float(1000000.0)
    hitColorR := float(0.0)
    hitColorG := float(0.0)
    hitColorB := float(0.0)

    // Ray-triangle intersection
    for i := 0; i < 32; i++ {
        dist, hit := rayTriangleIntersect(CameraPos, rayDir, 
            TrianglesV1X[i], TrianglesV1Y[i], TrianglesV1Z[i],
            TrianglesV2X[i], TrianglesV2Y[i], TrianglesV2Z[i],
            TrianglesV3X[i], TrianglesV3Y[i], TrianglesV3Z[i])
        if hit && dist < nearestDist {
            nearestDist = dist
            hitColorR = TrianglesColorR[i]
            hitColorG = TrianglesColorG[i]
            hitColorB = TrianglesColorB[i]
        }
    }
    return vec4(hitColorR, hitColorG, hitColorB, 1.0)
}